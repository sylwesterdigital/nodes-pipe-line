<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">


  <meta name="theme-color" content="#13141a">
  <link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;Node Canvas&quot;,&quot;display&quot;:&quot;standalone&quot;}">
  <title>Node Editor — projects, persistence, history (IndexedDB)</title>

  <style>
    /* Base + mobile hygiene */
    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { height:100%; }
    :root{
      --bg:#13141a; --panel:#1b1c25; --muted:#242633; --muted-2:#343647; --text:#e5e7eb;
      --pill:#0f172a; --pill-b:#334155; --shadow:rgba(0,0,0,.4);
      --fs:16px;
    }
    * { -webkit-tap-highlight-color: transparent; -webkit-user-select: none; user-select: none; }
    body { overscroll-behavior: none; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      font-size: var(--fs);
      background:var(--bg); color:var(--text);
      height:100vh; display:flex;
    }

    input, textarea {
      font-size:16px;
    }

    button {
      touch-action: manipulation;
    }        

    /* Sidebar */
    #sidebar {
      width:min(340px, 88vw);
      padding:16px; border-right:1px solid #2e2f3a; background:var(--panel);
      display:none; flex-direction:column; gap:12px;
      position:absolute; z-index:40; left:12px; top:60px;
      border-radius:12px; box-shadow:0 20px 60px var(--shadow);
    }
    #sidebar h1 { font-size:18px; }
    #sidebar .hint { font-size:16px; line-height:1.5; padding:10px; border-radius:10px; background:var(--muted); border:1px solid var(--muted-2); }

    /* Canvas area */
    #canvas-wrapper { flex:1; position:relative; overflow:hidden; }
    #canvas { width:100%; height:100%; background: radial-gradient(circle at top left, #25273a 0, #151623 55%); }
    #canvas, .node { touch-action:none; }

    .node { cursor: grab; transition: transform 120ms ease; transform-box: fill-box; transform-origin: center; }
    .node:active { cursor: grabbing; }
    .node:hover { transform: scale(1.06); }
    .node text { fill:var(--text); font-size:16px; pointer-events:none; }

    .link { stroke:var(--text); stroke-width:2; stroke-linecap:round; }
    .link-shadow { stroke:rgba(0,0,0,0.6); stroke-width:4; stroke-linecap:round; }
    #temp-link { stroke:#fbbf24; stroke-width:2; stroke-dasharray:4 3; stroke-linecap:round; pointer-events:none; display:none; }

    #status {
      position:absolute;
      left:12px;
      top:12px;        /* was bottom:12px; */
      bottom:auto;     /* optional: to override previous bottom if any */
      padding:8px 12px;
      border-radius:999px;
      background:rgba(15,23,42,0.88);
      border:1px solid rgba(148,163,184,0.5);
      font-size:16px;
    }


    #menu {
      position:absolute; min-width:200px; background:#0f172a; border:1px solid #334155;
      border-radius:10px; box-shadow:0 10px 30px var(--shadow); padding:6px; display:none; z-index:20;
    }
    #menu button {
      width:100%; text-align:left; padding:10px 12px; background:transparent; color:var(--text);
      border:none; border-radius:8px; font-size:16px;
    }
    #menu button:hover { background:#1f2937; }
    #menu .danger:hover { background:#3b1f27; color:#fecaca; }
    #menu hr { border:0; border-top:1px solid #334155; margin:6px 0; }

    /* Topbar */
    #topbar {
      position: absolute; right: 12px; top: 12px; z-index: 35;
      display: flex; gap: 8px; background: var(--pill); border: 1px solid var(--pill-b);
      padding: 6px 8px; border-radius: 999px; font-size: 14px; align-items: center;
    }
    #topbar .label, #topbar .kbd, #topbar .sep { display:none; }

    .btn {
      appearance: none; border: 1px solid var(--muted-2); background: var(--muted);
      color: var(--text); padding: 8px 12px; border-radius: 10px; font-size: 16px; cursor: pointer;
    }
    .btn:hover { filter: brightness(1.06); }
    .btn.primary { background:#1f2a44; border-color:#2a3a5f; }
    .btn.danger  { background:#3b1f27; border-color:#5b2531; color:#fecaca; }

    #btn-help, #btn-switch, #btn-new { display:inline-flex; align-items:center; justify-content:center; min-width:44px; }

    /* Only hide dup/del by default */
    #btn-dup,
    #btn-del {
      display:none;
    }

    @media (min-width: 768px) {
      #topbar .label,
      #topbar .kbd,
      #topbar .sep { display:inline; }

      #btn-dup,
      #btn-del {
        display:inline-flex;
      }
    }


    /* Palette */
    #palette {
      position:absolute; right:12px; bottom:12px; z-index:15; display:flex; gap:10px;
      background: var(--pill); border:1px solid var(--pill-b); padding:8px 10px; border-radius:12px; align-items:center;
    }
    .swatch { width:28px; height:28px; border-radius:6px; border:1px solid rgba(255,255,255,.2); cursor:pointer; position:relative; }
    .swatch.selected { outline:2px solid #fff; outline-offset:2px; }
    .swatch.picker { display:grid; place-items:center; font-size:18px; width:32px; height:32px; border-radius:8px; }
    .swatch.picker span { pointer-events:none; }

    /* Invisible color-input overlay anchored to ＋ swatch */
    /* keep color input off-screen, no hit area to zoom to */
    #palette-color-input {
      position:fixed;
      left:-9999px;
      top:auto;
      width:1px;
      height:1px;
      opacity:0;
      border:none;
      padding:0;
      margin:0;
      background:transparent;
    }

    .disabled-cover { position:absolute; inset:0; pointer-events:auto; }

    /* Project gate modal */
    #project-gate{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.6); z-index:50;
    }
    #project-card{
      width:min(620px,92vw); background:var(--panel); border:1px solid var(--muted-2);
      border-radius:14px; box-shadow:0 20px 60px var(--shadow); padding:16px; display:flex; flex-direction:column; gap:10px;
    }
    #project-card h2{ font-size:18px; margin-bottom:6px; }
    #projects-list{ max-height:260px; overflow:auto; border:1px solid var(--muted-2); border-radius:10px; padding:4px; background:var(--bg); }
    .proj-row{ display:flex; align-items:center; justify-content:space-between; padding:10px; border-radius:8px; gap:10px; }
    .proj-row:hover{ background:#222536; }
    .proj-name{ font-size:16px; }
    .proj-meta{ font-size:12px; opacity:.8; }
    .row-actions{ display:flex; gap:8px; }
    #project-form{ display:flex; gap:8px; margin-top:8px; }
    #project-name{
      flex:1; padding:10px 12px; border-radius:8px; border:1px solid var(--muted-2);
      background:#0f1222; color:#e5e7eb; font-size:16px;
    }

    .project-card-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }

    .project-close-btn{
      min-width:auto;
      padding:4px 10px;
      line-height:1;
      font-size:16px;
    }

    /* --- Mobile UI additions (exact placement: appended at end of <style>) --- */
    #hamburger{position:absolute;right:12px;top:12px;z-index:40;background:var(--pill);border:1px solid var(--pill-b);border-radius:10px;width:44px;height:44px;display:grid;place-items:center}
    #hamburger span{font-size:20px;line-height:1}
    #hamburger-menu{position:absolute;right:12px;top:60px;z-index:41;background:#0f172a;border:1px solid #334155;border-radius:12px;box-shadow:0 12px 30px var(--shadow);display:none;min-width:200px;overflow:hidden}
    #hamburger-menu button{width:100%;padding:12px 14px;background:transparent;border:0;color:var(--text);text-align:left;font-size:16px}
    #hamburger-menu button:hover{background:#1f2937}

    #mobile-undo-redo{
      position:absolute;
      right:12px;
      bottom:72px;
      z-index:40;
      display:flex;
      gap:8px;
      background:var(--pill);
      padding:6px;
    }

    @media(min-width:768px){
      #hamburger,
      #hamburger-menu{
        display:none;
      }
    }

    #tool-rail{
      position:absolute;
      left:12px;
      top:68px;
      bottom:12px;
      width:56px;
      z-index:38;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:none;
    }

    #tool-rail .tool{
      pointer-events:auto; 
    }

    .tool{
      flex:0 0 auto;
      display:grid;
      place-items:center;
      height:44px;
      border-radius:10px;
      border:1px solid var(--muted-2);
      background:var(--muted);
      font-size:12px;
      color:#ffffff;            
    }
    .tool.active{outline:2px solid #fff;outline-offset:2px}
    .tool .lbl{
      pointer-events:none;
      font-size:11px;
      color:#ffffff;             
    }

    /* Node description overlay */
    #desc-overlay{
      position:absolute;
      inset:0;
      display:none;              /* flex when active */
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.65);
      z-index:70;
      padding:16px;
    }

    #desc-card{
      width:min(640px, 96vw);
      max-height:80vh;
      background:var(--panel);
      border:1px solid var(--muted-2);
      border-radius:14px;
      box-shadow:0 24px 80px var(--shadow);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
    }

    #desc-card h2{
      font-size:18px;
    }

    #desc-node-label{
      font-size:16px;
      opacity:.8;
    }

    #desc-text{
      width:100%;
      min-height:120px;
      max-height:40vh;
      resize:vertical;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--muted-2);
      background:#020617;
      color:var(--text);
      font-size:16px;
      line-height:1.4;
    }

    .desc-actions{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-top:4px;
    }

    /* Rename node overlay */
    #rename-overlay{
      position:absolute;
      inset:0;
      display:none;              /* flex when active */
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.65);
      z-index:71;
      padding:16px;
    }

    #rename-card{
      width:min(480px, 90vw);
      background:var(--panel);
      border:1px solid var(--muted-2);
      border-radius:14px;
      box-shadow:0 24px 80px var(--shadow);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    #rename-card h2{
      font-size:18px;
    }

    #rename-input{
      width:100%;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--muted-2);
      background:#020617;
      color:var(--text);
      font-size:16px;
    }

    @media (max-width: 767px) {
      #topbar { display:none; }
    }

    #zoom-controls{
      position:absolute;
      left:12px;
      bottom: 12px;
      z-index:40;
      display:flex;
      flex-direction:column;   /* stack vertically */
      gap:8px;
      align-items:center;      /* keep them narrow */
      background:var(--pill);
      font-size:14px;
    }

    /* make the zoom buttons compact */
    #zoom-controls .btn{
      min-width:40px;          /* narrow buttons */
      padding:6px 10px;        /* smaller padding */
    }

    #zoom-reset {
      font-size: 12px;
    }

    /* zoom label spacing & size */
    #zoom-controls #zoom-label{
      min-width:auto;
      margin:2px 0;
      font-size:13px;
      text-align:center;
    }






  </style>
</head>
<body>
  <aside id="sidebar">
    <h1>Node Canvas</h1>
    <div class="hint">
      • Create/open a project to enable the canvas.<br>
      • Drag a node to move it (links follow). Long-press a node for actions.<br>
      • Desktop: hover a node and press N to start a link.<br>
      • Touch: start connection, touch canvas to begin guide, lift on target node.<br>
      • Undo/Redo: Ctrl/⌘+Z / Ctrl/⌘+Y (desktop). Save: Ctrl/⌘+S.<br>
      • Create node: click/tap empty canvas (not on an existing node).<br>
      • Mobile: use the left tool rail (Lines/Edit/Delete) to change tap behavior.
      • Pan canvas: hold Space and drag, or drag with the middle mouse button on empty canvas.<br>
      • Mobile: drag with two fingers on empty canvas to pan the canvas.<br>

    </div>
  </aside>


  <!-- Node description overlay -->
  <div id="desc-overlay">
    <div id="desc-card">
      <h2>Node description</h2>
      <div id="desc-node-label"></div>
      <textarea id="desc-text" placeholder="Describe this node…"></textarea>
      <div class="desc-actions">
        <button id="desc-cancel" class="btn">Cancel</button>
        <button id="desc-save" class="btn primary">Save</button>
      </div>
    </div>
  </div>

  <!-- Rename node overlay -->
  <div id="rename-overlay">
    <div id="rename-card">
      <h2>Rename node</h2>
      <input id="rename-input" placeholder="Node title" />
      <div class="desc-actions">
        <button id="rename-cancel" class="btn">Cancel</button>
        <button id="rename-save" class="btn primary">Save</button>
      </div>
    </div>
  </div>

  <div id="canvas-wrapper">


    <div id="zoom-controls">
      <button id="zoom-out"   class="btn" title="Zoom out">−</button>
      <span id="zoom-label">100%</span>
      <button id="zoom-in"    class="btn" title="Zoom in">+</button>
      <button id="zoom-reset" class="btn" title="Reset zoom to 100%">100%</button>
      <button id="zoom-fit"   class="btn" title="Fit all nodes">⤢</button>
    </div>

    <svg id="canvas">
      <g id="links-layer"></g>
      <line id="temp-link" x1="0" y1="0" x2="0" y2="0"></line>
      <!-- little marker when hovering / snapping over a line -->
      <circle id="hover-dot"
      r="4"
      fill="#ffffff"
      stroke="#000000"
      stroke-width="1"
      style="display:none; pointer-events:none;"></circle>
      <g id="nodes-layer"></g>
    </svg>

    <div id="menu">
      <button data-action="connect">Start connection</button>
      <button data-action="rename">Rename…</button>
      <button data-action="description">Description…</button> 
      <button data-action="duplicate">Duplicate</button>
      <hr>
      <button class="danger" data-action="delete">Delete</button>
    </div>

    <div id="topbar">
      <button id="btn-help" class="btn" title="Show help">?</button>
      <span class="label">Project:</span>
      <span id="proj-label" class="kbd">—</span>
      <span class="sep">|</span>
      <button id="btn-switch" class="btn">Open…</button>
      <button id="btn-new" class="btn">New…</button>
      <button id="btn-dup" class="btn">Duplicate…</button>
      <button id="btn-del" class="btn danger">Delete</button>
    </div>

    <div id="palette"></div>
    <input id="palette-color-input" type="color" aria-label="Pick color" />

    <div id="status">Mode: create/open a project</div>

    <div id="project-gate" style="display:none;">
      <div id="project-card">
        <div class="project-card-header">
          <h2>Projects</h2>
          <button id="project-close" class="btn project-close-btn" aria-label="Close projects">×</button>
        </div>
        <div id="projects-list"></div>
        <div id="project-form">
          <input id="project-name" placeholder="New project name" />
          <button id="create-project" class="btn primary">Create</button>
        </div>
      </div>
    </div>

    <div id="gate-cover" class="disabled-cover" style="display:none;"></div>

    <!-- Mobile controls -->
    <button id="hamburger" aria-label="Menu"><span>☰</span></button>
    <div id="hamburger-menu" role="menu">
      <button data-mobile="hint">Hint</button>
      <button data-mobile="open">Open</button>
      <button data-mobile="new">New</button>
      <button data-mobile="dup">Duplicate</button>
      <button data-mobile="del">Delete</button>
      <button data-mobile="save">Save</button> 
    </div>

    <div id="mobile-undo-redo">
      <button id="btn-undo" class="btn" title="Undo">Undo</button>
      <button id="btn-redo" class="btn" title="Redo">Redo</button>
      <button id="btn-save" class="btn primary" title="Save">Save</button>
    </div>

    <div id="tool-rail">
      <button id="tool-lines"  class="tool" title="Lines mode"><span class="lbl">Lines</span></button>
      <button id="tool-edit"   class="tool" title="Edit mode"><span class="lbl">Edit</span></button>
      <button id="tool-delete" class="tool" title="Delete mode"><span class="lbl">Delete</span></button>
    </div>
  </div>

  <script>
    (function(){

      // ----- Core refs -----
      const svg = document.getElementById("canvas");
      const nodesLayer = document.getElementById("nodes-layer");
      const linksLayer = document.getElementById("links-layer");
      const tempLink = document.getElementById("temp-link");
      const hoverDot = document.getElementById("hover-dot");

      const statusEl = document.getElementById("status");
      const menu = document.getElementById("menu");
      const wrapper = document.getElementById("canvas-wrapper");
      const sidebar = document.getElementById("sidebar");
      const btnHelp = document.getElementById("btn-help");

      const gate = document.getElementById("project-gate");
      const listEl = document.getElementById("projects-list");
      const projNameInput = document.getElementById("project-name");
      const createBtn = document.getElementById("create-project");
      const projLabel = document.getElementById("proj-label");
      const projectClose = document.getElementById("project-close");

      const btnSwitch = document.getElementById("btn-switch");
      const btnNew    = document.getElementById("btn-new");
      const btnDup    = document.getElementById("btn-dup");
      const btnDel    = document.getElementById("btn-del");
      const btnUndo   = document.getElementById("btn-undo");
      const btnRedo   = document.getElementById("btn-redo");
      const btnSave   = document.getElementById("btn-save");
      const gateCover = document.getElementById("gate-cover");

      const zoomInBtn  = document.getElementById("zoom-in");
      const zoomOutBtn = document.getElementById("zoom-out");
      const zoomLabel  = document.getElementById("zoom-label");
      const zoomResetBtn = document.getElementById("zoom-reset");
      const zoomFitBtn   = document.getElementById("zoom-fit");


      const paletteEl = document.getElementById("palette");
      const colorInput = document.getElementById("palette-color-input");

      /* Description overlay refs */
      const descOverlay    = document.getElementById("desc-overlay");
      const descCard       = document.getElementById("desc-card");
      const descNodeLabel  = document.getElementById("desc-node-label");
      const descText       = document.getElementById("desc-text");
      const descCancelBtn  = document.getElementById("desc-cancel");
      const descSaveBtn    = document.getElementById("desc-save");

      /* Rename overlay refs */
      const renameOverlay  = document.getElementById("rename-overlay");
      const renameInput    = document.getElementById("rename-input");
      const renameCancel   = document.getElementById("rename-cancel");
      const renameSave     = document.getElementById("rename-save");

      /* Mobile refs */
      const hamburger = document.getElementById("hamburger");
      const hambMenu  = document.getElementById("hamburger-menu");

      const toolLines = document.getElementById("tool-lines");
      const toolEdit  = document.getElementById("tool-edit");
      const toolDelete= document.getElementById("tool-delete");





      // ----- Graph state -----
      let nodes = [], links = [], nextId = 1;

      // Palette state
      let palette = { colors: ['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected: 0 };

      let dragNode = null;
      let dragOffset = {x:0,y:0};
      let linkingFrom = null;
      let linkActive = false;       // follows pointer while linking
      let menuNode = null;
      let lastHoverNode = null;
      let dragCandidate = null;

      // Node state
      let selectedNodeId = null;
      let descNode = null;      // node currently being edited in description modal
      let renameNodeRef = null; // node currently being renamed

      // Pointer UX
      const LONG_PRESS_MS = 500;
      const DRAG_MENU_CANCEL_PX = 6;
      let pressTimer = null;
      let downX=0, downY=0;

      // Background tap → create node (but not during pan)
      let bgTapCandidate = null;
      const BG_TAP_CANCEL_PX = 6;      

      // Projects/History (IndexedDB)
      let db = null;
      const DB_NAME = "node-editor";
      const DB_VER = 1;
      let currentProject = null;
      let undoStack = [];
      let redoStack = [];

      /* Mobile tool modes */
      let linesMode = false;   // tap sequence of nodes to chain-connect
      let editMode  = false;   // tap opens node context menu
      let deleteMode= false;   // tap deletes node
      let chainFrom = null;    // last node tapped in linesMode
      let tapMoved  = false;   // tracks movement to distinguish drag vs tap

      // ----- Canvas view (endless pan via viewBox) -----
      const viewBox = { x: 0, y: 0, w: 0, h: 0 };
      let baseViewBox = { w: 0, h: 0 };   // initial viewBox size for zoom=1

      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      let viewBoxStart = { x: 0, y: 0 };
      let spacePressed = false;

      /* Zoom state */
      let zoom = 1;
      const MIN_ZOOM = 0.4;
      const MAX_ZOOM = 4;
      const ZOOM_STEP = 1.2;      

      function updateZoomLabel(){
        if (!zoomLabel) return;
        zoomLabel.textContent = `${(zoom * 100).toFixed(0)}%`;
      }

      function initViewBox() {
        const rect = svg.getBoundingClientRect();
        viewBox.w = rect.width || 1024;
        viewBox.h = rect.height || 768;

        baseViewBox.w = viewBox.w;
        baseViewBox.h = viewBox.h;

        zoom = 1;
        svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      }

      function updateViewBox() {
        svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      }


      function resetZoomTo100(){
        const rect = svg.getBoundingClientRect();
        // Fall back to current viewport if baseViewBox is not set
        viewBox.w = baseViewBox.w || rect.width || 1024;
        viewBox.h = baseViewBox.h || rect.height || 768;
        viewBox.x = 0;
        viewBox.y = 0;

        zoom = 1;
        updateViewBox();
        updateZoomLabel();
        setStatus("Zoom: 100%");
      }

      function getNodesBounds(){
        if (!nodes.length) return null;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        nodes.forEach(n => {
          if (n.x < minX) minX = n.x;
          if (n.x > maxX) maxX = n.x;
          if (n.y < minY) minY = n.y;
          if (n.y > maxY) maxY = n.y;
        });
        return { minX, maxX, minY, maxY };
      }

      function zoomToFit(){
        const rect = svg.getBoundingClientRect();
        const bounds = getNodesBounds();

        // If nothing on canvas: just reset
        if (!bounds) {
          resetZoomTo100();
          return;
        }

        const padding = 80;

        let contentW = (bounds.maxX - bounds.minX) || 1;
        let contentH = (bounds.maxY - bounds.minY) || 1;
        contentW += padding * 2;
        contentH += padding * 2;

        const viewportRatio = rect.width / rect.height;
        const contentRatio  = contentW / contentH;

        let boxW, boxH;
        if (contentRatio > viewportRatio) {
          // limited by width
          boxW = contentW;
          boxH = contentW / viewportRatio;
        } else {
          // limited by height
          boxH = contentH;
          boxW = contentH * viewportRatio;
        }

        const cx = (bounds.minX + bounds.maxX) / 2;
        const cy = (bounds.minY + bounds.maxY) / 2;

        viewBox.w = boxW;
        viewBox.h = boxH;
        viewBox.x = cx - boxW / 2;
        viewBox.y = cy - boxH / 2;

        updateViewBox();

        // Recompute zoom value relative to the base viewBox width
        const baseW = baseViewBox.w || rect.width || boxW;
        zoom = baseW / viewBox.w;
        updateZoomLabel();
        setStatus("Zoom: fit to map");
      }



      function applyZoomFactor(factor, clientX, clientY) {
        // Clamp target zoom
        const prevZoom = zoom;
        let nextZoom = zoom * factor;
        if (nextZoom < MIN_ZOOM) nextZoom = MIN_ZOOM;
        if (nextZoom > MAX_ZOOM) nextZoom = MAX_ZOOM;

        const allowedFactor = nextZoom / prevZoom;
        if (allowedFactor === 1) return;

        const rect = svg.getBoundingClientRect();

        // If no focus point given, zoom toward center of viewport
        const cx = clientX ?? (rect.left + rect.width / 2);
        const cy = clientY ?? (rect.top + rect.height / 2);

        // Convert screen point → SVG coords
        const pt = svg.createSVGPoint();
        pt.x = cx;
        pt.y = cy;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

        // Scale viewBox
        viewBox.w /= allowedFactor;
        viewBox.h /= allowedFactor;

        // Adjust origin so the focus SVG point stays under the same screen point
        const nx = svgP.x - ((cx - rect.left) / rect.width) * viewBox.w;
        const ny = svgP.y - ((cy - rect.top) / rect.height) * viewBox.h;
        viewBox.x = nx;
        viewBox.y = ny;

        zoom = nextZoom;
        updateViewBox();
        updateZoomLabel();
        setStatus(`Zoom: ${(zoom * 100).toFixed(0)}%`);

        updateViewBox();

        setStatus(`Zoom: ${(zoom * 100).toFixed(0)}%`);
      }



      function startPan(e) {
        isPanning = true;
        panStart.x = e.clientX;
        panStart.y = e.clientY;
        viewBoxStart.x = viewBox.x;
        viewBoxStart.y = viewBox.y;
        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onPanMove);
        svg.addEventListener("pointerup", endPan, { once: true });
        setStatus("Panning (Space + drag)");
      }

      function onPanMove(e) {
        if (!isPanning) return;
        const rect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / rect.width;
        const scaleY = viewBox.h / rect.height;
        const dx = (e.clientX - panStart.x) * scaleX;
        const dy = (e.clientY - panStart.y) * scaleY;
        viewBox.x = viewBoxStart.x - dx;
        viewBox.y = viewBoxStart.y - dy;
        updateViewBox();
      }

      function endPan(e) {
        isPanning = false;
        if (e.pointerId != null) {
          try { svg.releasePointerCapture(e.pointerId); } catch(_) {}
        }
        svg.removeEventListener("pointermove", onPanMove);
      }




      // ----- Utils -----

      function isTextEditingTarget(e){
        const el = e.target;
        if (!el) return false;
        const tag = el.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA") return true;
        if (el.isContentEditable) return true;
        return false;
      }


      // distance + projection of a point to a segment
      function pointSegmentInfo(px, py, x1, y1, x2, y2){
        const dx = x2 - x1;
        const dy = y2 - y1;
        if (dx === 0 && dy === 0){
          const d = dist(px, py, x1, y1);
          return { dist: d, t: 0, x: x1, y: y1 };
        }
        const tRaw = ((px - x1) * dx + (py - y1) * dy) / (dx*dx + dy*dy);
        const t = Math.max(0, Math.min(1, tRaw));      // clamp to segment
        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        const d = dist(px, py, projX, projY);
        return { dist: d, t, x: projX, y: projY };
      }

      // find the best link under (px,py)
      function findNearestLinkPoint(px, py, opts={}){
        const maxDist     = opts.maxDist ?? 24;
        const ignoreNodeId= opts.ignoreNodeId ?? null;
        let best = null;

        links.forEach(link => {
          const from = nodes.find(n => n.id === link.from);
          const to   = nodes.find(n => n.id === link.to);
          if (!from || !to) return;

          // optional: ignore links attached to a specific node
          if (ignoreNodeId && (from.id === ignoreNodeId || to.id === ignoreNodeId)) return;

          const info = pointSegmentInfo(px, py, from.x, from.y, to.x, to.y);

          // ignore very near endpoints (t ~ 0 or 1)
          if (info.dist <= maxDist && info.t > 0.08 && info.t < 0.92){
            if (!best || info.dist < best.info.dist){
              best = { link, from, to, info };
            }
          }
        });

        return best;
      }

      // create a new node on a link (click-on-line)
      function insertNodeOnNearestLink(px, py){
        const best = findNearestLinkPoint(px, py, { maxDist: 24 });
        if (!best) return false;

        // create node snapped onto the line
        const newId = nextId;
        addNodeWrapped(best.info.x, best.info.y);
        const newNode = nodes.find(n => n.id === newId);
        if (!newNode) return false;

        const originalColor =
        (best.link.style && best.link.style.color) || selectedColor();

        // remove original link
        links = links.filter(l => l !== best.link);

        // add two new links with same color
        links.push(
          { from: best.from.id, to: newNode.id, style: { color: originalColor } },
          { from: newNode.id,   to: best.to.id, style: { color: originalColor } }
          );
        renderLinks();

        pushAction({
          type: "SPLIT_LINK",
          at: Date.now(),
          from: best.from.id,
          to:   best.to.id,
          via:  newNode.id,
          color: originalColor
        });

        setStatus(`Inserted node between ${best.from.label} and ${best.to.label}`);
        return true;
      }

      // reuse splitting logic when dropping an existing node onto a link
      function splitExistingLinkWithNode(node, best){
        const original = best.link;
        const originalColor =
        (original.style && original.style.color) || selectedColor();

        // remove the original link
        links = links.filter(l => l !== original);

        // add two new links that pass through this node
        links.push(
          { from: best.from.id, to: node.id, style: { color: originalColor } },
          { from: node.id,      to: best.to.id, style: { color: originalColor } }
          );
        renderLinks();

        pushAction({
          type: "SPLIT_LINK_WITH_EXISTING_NODE",
          at: Date.now(),
          via:  node.id,
          from: best.from.id,
          to:   best.to.id,
          color: originalColor
        });

        setStatus(`Inserted ${node.label} into link ${best.from.label} → ${best.to.label}`);
      }





      function setStatus(text){ statusEl.textContent = text; }

      function showHoverDotAt(x, y){
        if (!hoverDot) return;
        hoverDot.setAttribute("cx", x);
        hoverDot.setAttribute("cy", y);
        hoverDot.style.display = "block";
      }

      function hideHoverDot(){
        if (!hoverDot) return;
        hoverDot.style.display = "none";
      }




      function svgPoint(evt){
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX; pt.y = evt.clientY;
        return pt.matrixTransform(svg.getScreenCTM().inverse());
      }
      function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }
      const selectedColor = ()=> palette.colors[palette.selected] || '#3b82f6';
      const normHex = (v)=>{
        let s = String(v||'').trim();
        if (!s) return '#3b82f6';
        if (s[0] !== '#') s = '#'+s;
        if (/^#([0-9a-f]{3})$/i.test(s)) s = '#'+s.slice(1).split('').map(x=>x+x).join('');
        if (!/^#([0-9a-f]{6})$/i.test(s)) return '#3b82f6';
        return s.toLowerCase();
      };

      function setNodeDescription(node, text){
        const old = node.description || "";
        node.description = text;
        pushAction({ type:"SET_DESCRIPTION", at:Date.now(), id:node.id, from:old, to:text });
      }

      function openDescriptionModal(node){
        descNode = node;
        descNodeLabel.textContent = `Node: ${node.label}`;
        descText.value = node.description || "";
        descOverlay.style.display = "flex";
      }

      function closeDescriptionModal(){
        descOverlay.style.display = "none";
        descNode = null;
      }

      function openRenameModal(node){
        renameNodeRef = node;
        renameInput.value = node.label || "";
        renameOverlay.style.display = "flex";
        setTimeout(() => {
          renameInput.focus();
          renameInput.select();
        }, 10);
      }

      function closeRenameModal(){
        renameOverlay.style.display = "none";
        renameNodeRef = null;
      }

      // ----- IndexedDB -----
      function openDB(){
        return new Promise((resolve, reject)=>{
          const req = indexedDB.open(DB_NAME, DB_VER);
          req.onupgradeneeded = (e)=>{
            const db = e.target.result;
            if (!db.objectStoreNames.contains("projects")) {
              const s = db.createObjectStore("projects", { keyPath: "id", autoIncrement: true });
              s.createIndex("by_name","name",{ unique: true });
            }
            if (!db.objectStoreNames.contains("states")) {
              const s2 = db.createObjectStore("states", { keyPath: ["projectId","rev"] });
              s2.createIndex("by_project","projectId");
            }
            if (!db.objectStoreNames.contains("history")) {
              const s3 = db.createObjectStore("history", { keyPath: ["projectId","seq"] });
              s3.createIndex("by_project","projectId");
            }
          };
          req.onsuccess = ()=> resolve(req.result);
          req.onerror   = ()=> reject(req.error);
        });
      }
      function tx(storeNames, mode="readonly"){ return db.transaction(storeNames, mode); }

      // ----- Projects API -----
      async function listProjects(){
        const out = [];
        await new Promise((res,rej)=>{
          const t = tx(["projects"]);
          const req = t.objectStore("projects").openCursor();
          req.onsuccess = (e)=>{ const cur=e.target.result; if(cur){ out.push(cur.value); cur.continue(); } else res(); };
          req.onerror  = ()=>rej(req.error);
        });
        return out.sort((a,b)=> (b.updatedAt||b.createdAt||0) - (a.updatedAt||a.createdAt||0));
      }
      async function createProject(name){
        const now = Date.now();
        const meta = { name, createdAt: now, updatedAt: now, pointer: 0, palette };
        const t = tx(["projects"],"readwrite");
        const req = t.objectStore("projects").add(meta);
        const id = await new Promise((res,rej)=>{ req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); });
        await saveStateSnapshot(id, 0, { nodes:[], links:[], nextId:1 });
        await saveHistoryRecord(id, 1, { type:"INIT", at: now });
        return { id, ...meta };
      }
      async function duplicateProject(sourceId, newName){
        const now = Date.now();
        const t = tx(["projects"],"readwrite");
        const origin = await new Promise((res,rej)=>{
          const r = t.objectStore("projects").get(sourceId);
          r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);
        });
        const addReq = t.objectStore("projects").add({ name:newName, createdAt: now, updatedAt: now, pointer: 0, palette: origin?.palette || palette });
        const newId = await new Promise((res,rej)=>{ addReq.onsuccess=()=>res(addReq.result); addReq.onerror=()=>rej(addReq.error); });

        let maxRev = 0;
        await new Promise((res,rej)=>{
          const t2 = tx(["states"],"readwrite");
          const idx = t2.objectStore("states").index("by_project").openCursor(IDBKeyRange.only(sourceId));
          idx.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {rev,state}=c.value; maxRev=Math.max(maxRev,rev); t2.objectStore("states").put({projectId:newId,rev,state:JSON.parse(JSON.stringify(state))}); c.continue(); } else res(); };
          idx.onerror=()=>rej(idx.error);
        });
        await new Promise((res,rej)=>{
          const t3 = tx(["history"],"readwrite");
          const idx = t3.objectStore("history").index("by_project").openCursor(IDBKeyRange.only(sourceId));
          idx.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {seq,action}=c.value; t3.objectStore("history").put({projectId:newId,seq,action:JSON.parse(JSON.stringify(action))}); c.continue(); } else res(); };
          idx.onerror=()=>rej(idx.error);
        });
        await new Promise((res,rej)=>{
          const t4 = tx(["projects"],"readwrite");
          const putReq = t4.objectStore("projects").put({ id:newId, name:newName, createdAt: now, updatedAt: now, pointer: maxRev, palette: origin?.palette || palette });
          putReq.onsuccess=()=>res(); putReq.onerror=()=>rej(putReq.error);
        });
        return { id:newId, name:newName, createdAt: now, updatedAt: now, pointer: maxRev, palette: origin?.palette || palette };
      }
      async function updateProjectMeta(patch){
        if (!currentProject) return;
        const now = Date.now();
        const t = tx(["projects"],"readwrite");
        const obj = { ...currentProject, ...patch, updatedAt: now };
        await new Promise((res,rej)=>{ const r=t.objectStore("projects").put(obj); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
        currentProject = obj;
        projLabel.textContent = currentProject.name;
      }

      // ----- Snapshots / History -----
      async function saveStateSnapshot(projectId, rev, state){
        const t = tx(["states"],"readwrite");
        await new Promise((res,rej)=>{ const r=t.objectStore("states").put({projectId,rev,state}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
      }
      async function loadLatestState(projectId){
        let maxRev=-1, latest=null;
        await new Promise((res,rej)=>{
          const t = tx(["states"]);
          const idx = t.objectStore("states").index("by_project");
          const r = idx.openCursor(IDBKeyRange.only(projectId));
          r.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {rev,state}=c.value; if(rev>maxRev){maxRev=rev; latest={rev,state};} c.continue(); } else res(); };
          r.onerror=()=>rej(r.error);
        });
        return latest || { rev:0, state:{ nodes:[], links:[], nextId:1 } };
      }
      async function saveHistoryRecord(projectId, seq, action){
        const t = tx(["history"],"readwrite");
        await new Promise((res,rej)=>{ const r=t.objectStore("history").put({projectId,seq,action}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
      }
      async function loadHistory(projectId){
        const items=[];
        await new Promise((res,rej)=>{
          const t = tx(["history"]);
          const idx = t.objectStore("history").index("by_project");
          const r = idx.openCursor(IDBKeyRange.only(projectId));
          r.onsuccess=(e)=>{ const c=e.target.result; if(c){ items.push(c.value); c.continue(); } else res(); };
          r.onerror=()=>rej(r.error);
        });
        items.sort((a,b)=>a.seq-b.seq);
        return items;
      }

      // ----- History helpers -----
      function snapshot(){ return { nodes: JSON.parse(JSON.stringify(nodes)), links: JSON.parse(JSON.stringify(links)), nextId }; }
      function applyState(state){ nodes = JSON.parse(JSON.stringify(state.nodes||[])); links = JSON.parse(JSON.stringify(state.links||[])); nextId = state.nextId || 1; renderAll(); }
      async function pushAction(action){ if (!currentProject) return; undoStack.push(snapshot()); redoStack.length = 0; await appendHistory(action); updateProjectMeta({}); }
      async function appendHistory(action){ const all = await loadHistory(currentProject.id); const nextSeq = (all.length? all[all.length-1].seq+1 : 1); await saveHistoryRecord(currentProject.id, nextSeq, action); }
      async function rebuildStacksFromHistory(){ undoStack.length=0; redoStack.length=0; undoStack.push(snapshot()); }
      async function doUndo(){ if (!currentProject || undoStack.length<=1) return; const cur=undoStack.pop(); redoStack.push(cur); const prev=undoStack[undoStack.length-1]; applyState(prev); setStatus("Undo"); await persistSnapshot(); }
      async function doRedo(){ if (!currentProject || !redoStack.length) return; const nxt=redoStack.pop(); undoStack.push(nxt); applyState(nxt); setStatus("Redo"); await persistSnapshot(); }
      async function persistSnapshot(){ if (!currentProject) return; const latest=await loadLatestState(currentProject.id); const newRev=latest.rev+1; await saveStateSnapshot(currentProject.id,newRev,snapshot()); await updateProjectMeta({pointer:newRev, palette}); setStatus(`Saved rev ${newRev}`); }

      // ----- Graph CRUD -----
      function makeDefaultStyle(){
        const c = selectedColor();
        return { shape:'pill', fill:c, stroke:c };
      }

      function addNodeWrapped(x,y){
        const node={id:nextId++,x,y,label:"N"+(nextId-1), style: makeDefaultStyle()};
        nodes.push(node);
        selectedNodeId = node.id;
        renderNodes();
        renderLinks();
        pushAction({type:"ADD_NODE",at:Date.now(),node});
      }

      function moveNodeWrapped(node){
        renderLinks();
        pushAction({type:"MOVE_NODE",at:Date.now(),id:node.id,x:node.x,y:node.y});
      }

      function deleteNodeWrapped(node){
        nodes=nodes.filter(n=>n.id!==node.id);
        links=links.filter(l=>l.from!==node.id&&l.to!==node.id);
        if (selectedNodeId === node.id) selectedNodeId = null;
        renderAll();
        pushAction({type:"DELETE_NODE",at:Date.now(),id:node.id});
      }

      function duplicateNodeWrapped(node, keepLabel=false){
        const newLabel = keepLabel ? (node.label ? node.label + "1" : "N"+nextId) : ("N"+nextId);
        const n2={ id:nextId++, x:node.x+28, y:node.y+28, label:newLabel, style: JSON.parse(JSON.stringify(node.style||makeDefaultStyle())) };
        nodes.push(n2);
        renderAll();
        pushAction({type:"DUPLICATE_NODE",at:Date.now(),from:node.id,to:n2.id});
      }

      function connectNodesWrapped(aId,bId){
        links.push({from:aId,to:bId, style:{color:selectedColor()}});
        renderLinks();
        pushAction({type:"CONNECT",at:Date.now(),from:aId,to:bId,color:selectedColor()});
      }

      function renameNodeWrapped(node,newLabel){
        const old=node.label;
        node.label=newLabel;
        updateNodeGraphics(node);
        pushAction({type:"RENAME_NODE",at:Date.now(),id:node.id,from:old,to:newLabel});
      }

      function restyleNodeWrapped(node, patch){
        node.style = { ...(node.style||makeDefaultStyle()), ...patch };
        updateNodeGraphics(node);
        pushAction({type:"STYLE_NODE", at:Date.now(), id:node.id, patch});
      }

      // ----- Rendering -----
      function renderNodes() {
        nodesLayer.innerHTML = "";
        nodes.forEach(node => {
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.classList.add("node");
          g.dataset.id = String(node.id);

          const style = node.style || makeDefaultStyle();
          const isSelected = node.id === selectedNodeId;

          let shapeEl;
          if (style.shape === 'pill' || !style.shape) {
            const label = node.label || "";
            const baseWidth = 72;
            const dynWidth  = label.length * 9 + 24;
            const width     = Math.max(baseWidth, dynWidth);
            const height    = 32;

            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            shapeEl.setAttribute("x", node.x - width / 2);
            shapeEl.setAttribute("y", node.y - height / 2);
            shapeEl.setAttribute("width",  width);
            shapeEl.setAttribute("height", height);
            shapeEl.setAttribute("rx", height / 2);
          } else if (style.shape === 'rect') {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            shapeEl.setAttribute("x", node.x - 18);
            shapeEl.setAttribute("y", node.y - 18);
            shapeEl.setAttribute("width", 36);
            shapeEl.setAttribute("height", 36);
            shapeEl.setAttribute("rx", 6);
          } else if (style.shape === 'triangle') {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            const p1 = `${node.x},${node.y-20}`;
            const p2 = `${node.x-18},${node.y+16}`;
            const p3 = `${node.x+18},${node.y+16}`;
            shapeEl.setAttribute("points", `${p1} ${p2} ${p3}`);
          } else {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            shapeEl.setAttribute("cx", node.x);
            shapeEl.setAttribute("cy", node.y);
            shapeEl.setAttribute("r", 18);
          }

          shapeEl.setAttribute("fill", style.fill);
          shapeEl.setAttribute("stroke", isSelected ? "#ffffff" : style.stroke);
          shapeEl.setAttribute("stroke-width", isSelected ? "3" : "2");

          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", node.x);
          text.setAttribute("y", node.y + 4);
          text.setAttribute("text-anchor", "middle");
          text.textContent = node.label;

          g.appendChild(shapeEl);
          g.appendChild(text);
          nodesLayer.appendChild(g);

          g.addEventListener("pointerenter", ()=>{ lastHoverNode = node; });
          g.addEventListener("pointerleave", ()=>{ if (lastHoverNode && lastHoverNode.id===node.id) lastHoverNode=null; });

          g.addEventListener("pointerdown", (e)=>onNodePointerDown(e, node));
          g.addEventListener("contextmenu", (e)=>openMenu(e, node));
          g.addEventListener("pointerdown", (e)=>startPressTimer(e, node));
          g.addEventListener("pointerup", cancelPressTimer, { passive:true });
          g.addEventListener("pointerleave", cancelPressTimer, { passive:true });

          /* Mobile taps and two-finger menu */
          g.addEventListener("pointerdown", ()=>{ tapMoved=false; });
          g.addEventListener("pointermove", ()=>{ tapMoved=true; });
          g.addEventListener("pointerup", (e)=> handleNodePointerUp(e, node), { passive:true });
          g.addEventListener("touchstart", (e)=> maybeTwoFingerMenu(e, node), { passive:false });
          g.addEventListener("touchend", clearTwoFingerTimer, { passive:true });
          g.addEventListener("touchmove", clearTwoFingerTimer, { passive:true });
        });
        setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
      }

      function renderLinks() {
        linksLayer.innerHTML = "";
        links.forEach(link => {
          const from = nodes.find(n => n.id === link.from);
          const to   = nodes.find(n => n.id === link.to);
          if (!from || !to) return;

          const shadow = document.createElementNS("http://www.w3.org/2000/svg", "line");
          shadow.classList.add("link-shadow");
          shadow.setAttribute("x1", from.x); shadow.setAttribute("y1", from.y);
          shadow.setAttribute("x2", to.x);   shadow.setAttribute("y2", to.y);

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.classList.add("link");
          line.setAttribute("x1", from.x); line.setAttribute("y1", from.y);
          line.setAttribute("x2", to.x);   line.setAttribute("y2", to.y);
          if (link.style && link.style.color) line.setAttribute("stroke", link.style.color);

          linksLayer.appendChild(shadow);
          linksLayer.appendChild(line);
        });
        setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
      }

      function renderAll(){ renderNodes(); renderLinks(); }
      function updateNodeGraphics(){ renderAll(); }

      // ----- Context menu -----
      function openMenu(e, node){
        if (linkingFrom || dragNode) return;
        e.preventDefault();

        cancelPressTimer();
        dragCandidate = null;

        closeMenu();
        menuNode = node;
        const rect = wrapper.getBoundingClientRect();
        const x = Math.min(e.clientX - rect.left, rect.width - 220);
        const y = Math.min(e.clientY - rect.top,  rect.height - 180);
        menu.style.left = x + "px";
        menu.style.top  = y + "px";
        menu.style.display = "block";
      }

      function closeMenu(){ menu.style.display = "none"; menuNode = null; }

      menu.addEventListener("click", (e)=>{
        const btn = e.target.closest("button");
        if (!btn || !menuNode) return;
        const action = btn.dataset.action;

        if (action === "connect") {
          const from = menuNode;
          closeMenu();
          startConnectionFrom(from, { immediateFollow: true });
          return;
        }

        if (action === "rename") {
          const node = menuNode;
          closeMenu();
          openRenameModal(node);
          return;
        }

        if (action === "description") {
          const node = menuNode;
          closeMenu();
          openDescriptionModal(node);
          return;
        }

        if (action === "duplicate") { duplicateNodeWrapped(menuNode, true); }
        if (action === "delete")    { deleteNodeWrapped(menuNode); }

        closeMenu();
      });

      wrapper.addEventListener("pointerdown", (e)=>{
        if (e.target === svg) closeMenu();
      });

      // ----- Space key pan mode -----
      window.addEventListener("keydown", (e) => {
        if (isTextEditingTarget(e)) return;  // do nothing while typing
        if (e.code === "Space" && !spacePressed) {
          spacePressed = true;
          svg.style.cursor = "grab";
          e.preventDefault();
        }
      });



      window.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          spacePressed = false;
          if (!isPanning) {
            svg.style.cursor = "";
          }
        }
      });

      // ----- Keyboard (desktop) -----
      window.addEventListener("keydown", async (e)=>{
        if (isTextEditingTarget(e)) return;   // ignore shortcuts while typing

        const mod = e.ctrlKey || e.metaKey;
        const k = e.key.toLowerCase();


        if (mod && k==="s"){ e.preventDefault(); await persistSnapshot(); return; }
        if (mod && k==="z"){ e.preventDefault(); await doUndo(); return; }
        if (mod && k==="y"){ e.preventDefault(); await doRedo(); return; }

        if (k === "escape") {
          if (gate.style.display === "flex") {
            gateOff();
            return;
          }
          if (renameOverlay.style.display === "flex") { closeRenameModal(); return; }
          if (descOverlay.style.display === "flex") { closeDescriptionModal(); return; }
          closeMenu();
          cancelLinking();
          return;
        }

        if (!currentProject) return;
        if (k==="n"){
          if (!linkingFrom && lastHoverNode){
            closeMenu();
            startConnectionFrom(lastHoverNode, { immediateFollow: true });
          }
        }
        if (k==="x"){ if (lastHoverNode){ deleteNodeWrapped(lastHoverNode); } }
        if (e.shiftKey && k==="d"){ if (lastHoverNode){ duplicateNodeWrapped(lastHoverNode, true); } }
      });

      // ----- Pointer-based drag/move -----
      function startPressTimer(e, node){
        if (linkingFrom) return;
        cancelPressTimer();
        downX = e.clientX; downY = e.clientY;
        pressTimer = setTimeout(()=>{ openMenu(e, node); }, LONG_PRESS_MS);
      }

      function cancelPressTimer(){
        if (pressTimer){ clearTimeout(pressTimer); pressTimer=null; }
      }

      function onNodePointerDown(e, node){
        if (!currentProject){ gateOn(); return; }

        // Right-click → open menu immediately
        if (e.button === 2){
          openMenu(e, node);
          return;
        }
        // Ignore middle button (used for pan on background)
        if (e.button === 1) return;

        // If currently linking and a node is pressed, finish the connection.
        if (linkingFrom){
          e.preventDefault();
          if (node.id !== linkingFrom.id) { connectNodesWrapped(linkingFrom.id, node.id); }
          cancelLinking();
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        dragCandidate = { node, pointerId: e.pointerId };

        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onCanvasPointerMove);
        svg.addEventListener("pointerup", onCanvasPointerUp, { once:true });
      }

      function onCanvasPointerMove(e){
        if (pressTimer && dist(e.clientX,e.clientY,downX,downY) > DRAG_MENU_CANCEL_PX) {
          cancelPressTimer();
        }

        if (linkingFrom && linkActive){
          const p = svgPoint(e);
          tempLink.setAttribute("x2", p.x);
          tempLink.setAttribute("y2", p.y);
          return;
        }

        // No active drag yet: turn candidate into real drag if moved enough
        if (!dragNode && dragCandidate && e.pointerId === dragCandidate.pointerId){
          const p = svgPoint(e);
          const node = dragCandidate.node;
          dragNode = node;
          dragOffset.x = node.x - p.x;
          dragOffset.y = node.y - p.y;
          dragCandidate = null;

          selectedNodeId = node.id;
          updateNodeGraphics();

          setStatus(`Dragging ${node.label}`);
        }

        if (!dragNode) return;

        const p = svgPoint(e);
        dragNode.x = p.x + dragOffset.x;
        dragNode.y = p.y + dragOffset.y;
        renderAll();

        // while dragging, show dot at the link we would insert into
        const best = findNearestLinkPoint(
          dragNode.x,
          dragNode.y,
          { maxDist: 24, ignoreNodeId: dragNode.id }
          );
        if (best) showHoverDotAt(best.info.x, best.info.y);
        else      hideHoverDot();
      }

      function onCanvasPointerUp(e){
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        cancelPressTimer();
        dragCandidate = null;

        if (dragNode){
          const movedNode = dragNode;

          // see if this node was dropped onto a link (ignore links it already ends on)
          const best = findNearestLinkPoint(
            movedNode.x,
            movedNode.y,
            { maxDist: 24, ignoreNodeId: movedNode.id }
            );

          // first: finalize movement (records MOVE_NODE in history)
          moveNodeWrapped(movedNode);

          // then: if we had a link under us, split it using this node
          if (best){
            splitExistingLinkWithNode(movedNode, best);
          }

          dragNode = null;
        }

        hideHoverDot();
      }




      // ----- Mobile two-finger pan (endless canvas on touch) -----
      let touchPanActive = false;
      let touchPanStart = { x: 0, y: 0 };
      let touchViewBoxStart = { x: 0, y: 0 };

      svg.addEventListener("touchstart", (e) => {
        // Only start panning on background, with two fingers
        if (e.touches.length === 2 && e.target === svg) {
          e.preventDefault();
          touchPanActive = true;

          // Do not treat this gesture as a tap that can create a node
          bgTapCandidate = null;

          // IMPORTANT: use the midpoint between the two fingers
          const mid = getTouchMidpoint(e);
          touchPanStart.x = mid.x;
          touchPanStart.y = mid.y;

          touchViewBoxStart.x = viewBox.x;
          touchViewBoxStart.y = viewBox.y;
          setStatus("Panning (two-finger drag)");
        }
      }, { passive: false });

      svg.addEventListener("touchmove", (e) => {
        if (!touchPanActive) return;
        if (e.touches.length !== 2) return;

        e.preventDefault();

        const rect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / rect.width;
        const scaleY = viewBox.h / rect.height;

        // Again, use the midpoint for pan
        const mid = getTouchMidpoint(e);
        const dx = (mid.x - touchPanStart.x) * scaleX;
        const dy = (mid.y - touchPanStart.y) * scaleY;

        viewBox.x = touchViewBoxStart.x - dx;
        viewBox.y = touchViewBoxStart.y - dy;
        updateViewBox();
      }, { passive: false });

      svg.addEventListener("touchend", (e) => {
        // When fingers are lifted, stop panning
        if (e.touches.length < 2 && touchPanActive) {
          touchPanActive = false;
          setStatus("Mode: pan / add nodes");
        }
      });



      // ----- Background: pan or tap-to-add node -----
      svg.addEventListener("pointerdown", (e)=>{
        if (e.button === 2) e.preventDefault();

        // if click started on an existing node, do nothing here
        const nodeHit = e.target.closest(".node");
        if (nodeHit) return;

        // only act on raw SVG background, not layers/lines
        if (e.target !== svg) return;

        // If we are currently doing a two-finger pan, ignore taps
        if (touchPanActive) return;

        // Space + drag or middle mouse on background → pan (desktop)
        if (spacePressed || e.button === 1) {
          startPan(e);
          return;
        }

        if (!currentProject){ gateOn(); return; }
        if (linkingFrom){ cancelLinking(); setStatus("Link cancelled"); return; }

        // Start a tap candidate; we will only create the node on pointerup
        bgTapCandidate = {
          pointerId: e.pointerId,
          startX: e.clientX,
          startY: e.clientY
        };

        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onBgPointerMove);
        svg.addEventListener("pointerup", onBgPointerUp, { once:true });
      });

      // hover feedback: little white dot on the closest line
      svg.addEventListener("pointermove", (e)=>{
        if (!currentProject) { hideHoverDot(); return; }

        // while dragging or linking or panning, let other logic handle it
        if (dragNode || dragCandidate || linkingFrom || isPanning || touchPanActive) {
          // dragNode case is handled in onCanvasPointerMove
          if (!dragNode) hideHoverDot();
          return;
        }

        const p = svgPoint(e);
        const best = findNearestLinkPoint(p.x, p.y, { maxDist: 18 });
        if (best) showHoverDotAt(best.info.x, best.info.y);
        else hideHoverDot();
      });

      svg.addEventListener("pointerleave", () => {
        hideHoverDot();
      });




      let pinchLastDistance = null;

      function getTouchDistance(e){
        if (e.touches.length < 2) return null;
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.hypot(dx, dy);
      }

      function getTouchMidpoint(e){
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        return {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2
        };
      }

      svg.addEventListener("touchstart", (e)=>{
        if (e.touches.length === 2){
          pinchLastDistance = getTouchDistance(e);
        }
      }, { passive:true });

      svg.addEventListener("touchmove", (e)=>{
        if (e.touches.length === 2 && pinchLastDistance){
          const d = getTouchDistance(e);
          if (!d) return;

          const factor = d / pinchLastDistance;
          const mid = getTouchMidpoint(e);
          applyZoomFactor(factor, mid.x, mid.y);
          pinchLastDistance = d;

          // prevent the browser default pinch-zoom
          e.preventDefault();
        }
      }, { passive:false });

      svg.addEventListener("touchend", (e)=>{
        if (e.touches.length < 2){
          pinchLastDistance = null;
        }
      });






      svg.addEventListener("wheel", (e) => {
        // Trackpad "two-finger drag" also comes in as wheel events.
        // Prevent page scroll and use it for pan / zoom.
        e.preventDefault();

        const rect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / rect.width;
        const scaleY = viewBox.h / rect.height;

        // Hold Ctrl/⌘ to zoom, otherwise pan.
        if (e.ctrlKey || e.metaKey) {
          const factor = e.deltaY < 0 ? ZOOM_STEP : 1 / ZOOM_STEP;
          applyZoomFactor(factor, e.clientX, e.clientY);
        } else {
          // Pan based on wheel deltas (works nicely with trackpad two-finger scroll)
          viewBox.x += e.deltaX * scaleX;
          viewBox.y += e.deltaY * scaleY;
          updateViewBox();
          setStatus("Panning (trackpad)");
        }
      }, { passive: false });


      function onBgPointerMove(e){
        if (!bgTapCandidate || e.pointerId !== bgTapCandidate.pointerId) return;
        const dx = e.clientX - bgTapCandidate.startX;
        const dy = e.clientY - bgTapCandidate.startY;
        if (Math.hypot(dx, dy) > BG_TAP_CANCEL_PX) {
          // too much movement → not a tap
          bgTapCandidate = null;
        }
      }

      function onBgPointerUp(e){
        svg.removeEventListener("pointermove", onBgPointerMove);
        try {
          svg.releasePointerCapture(e.pointerId);
        } catch(_) {}

        if (!bgTapCandidate || e.pointerId !== bgTapCandidate.pointerId){
          bgTapCandidate = null;
          return;
        }

        // If a two-finger pan was active during this gesture, do not add a node
        if (touchPanActive) {
          bgTapCandidate = null;
          return;
        }

        if (!currentProject){
          bgTapCandidate = null;
          return;
        }

        const p = svgPoint(e);

        // 1) first try: insert node on an existing link (gateway)
        if (insertNodeOnNearestLink(p.x, p.y)){
          bgTapCandidate = null;
          return;
        }

        // 2) fallback: normal "add node in empty space"
        const nearExisting = nodes.some(n => dist(n.x, n.y, p.x, p.y) < 32);
        if (!nearExisting) {
          addNodeWrapped(p.x, p.y);
        }

        bgTapCandidate = null;
      }





      gate.addEventListener("pointerdown", (e) => {
        if (e.target === gate) {
          gateOff();
        }
      });      

      // ----- Linking (desktop + touch) -----
      function startConnectionFrom(node, opts={}){
        if (!node) return;

        selectedNodeId = node.id;
        updateNodeGraphics();

        linkingFrom = node;
        tempLink.setAttribute("x1", node.x);
        tempLink.setAttribute("y1", node.y);
        tempLink.setAttribute("x2", node.x);
        tempLink.setAttribute("y2", node.y);
        tempLink.style.display = "block";

        if (opts.immediateFollow){
          linkActive = true;
          svg.addEventListener("pointermove", onCanvasPointerMove);
          setStatus(`Connecting from ${node.label}: move cursor, click a node to finish`);
        } else {
          setStatus(`Connecting from ${node.label}: touch canvas to start, lift on target node`);
          svg.addEventListener("pointerdown", onLinkPointerDown, { once:true });
        }
      }

      function onLinkPointerDown(e){
        if (!linkingFrom) return;
        e.preventDefault();
        linkActive = true;
        const p = svgPoint(e);
        tempLink.setAttribute("x2", p.x);
        tempLink.setAttribute("y2", p.y);
        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onCanvasPointerMove);
        svg.addEventListener("pointerup", onLinkPointerUp, { once:true });
      }

      function onLinkPointerUp(e){
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        linkActive = false;

        const hit = document.elementFromPoint(e.clientX, e.clientY);
        let group = hit && hit.closest ? hit.closest(".node") : null;
        if (group && linkingFrom){
          const toId = Number(group.dataset.id);
          if (toId && toId !== linkingFrom.id){ connectNodesWrapped(linkingFrom.id, toId); }
        }
        cancelLinking();
      }

      function cancelLinking(){
        linkingFrom = null;
        linkActive = false;
        tempLink.style.display = "none";
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        svg.removeEventListener("pointerdown", onLinkPointerDown);
        hideHoverDot();
      }


      // prevent context menu while dragging/linking
      nodesLayer.addEventListener("contextmenu", (e)=>{
        if (dragNode || linkingFrom){ e.preventDefault(); e.stopPropagation(); }
      });

      svg.addEventListener("contextmenu", (e)=>{
        if (dragNode || linkingFrom){ e.preventDefault(); }
      });

      // ----- Palette (anchored color input) -----
      function renderPalette(){
        paletteEl.innerHTML = "";

        palette.colors.slice(0,4).forEach((c, i)=>{
          const sw = document.createElement("div");
          sw.className = "swatch" + (palette.selected===i ? " selected" : "");
          sw.style.background = c;
          sw.title = `Color ${i+1}`;
          sw.addEventListener("click", ()=>{
            palette.selected = i;
            paletteEl.querySelectorAll(".swatch").forEach((el, idx)=>{
              if (!el.classList) return;
              if (idx === i) el.classList.add("selected");
              else el.classList.remove("selected");
            });
            updateProjectMeta({ palette });
            if (lastHoverNode) restyleNodeWrapped(lastHoverNode, { fill: palette.colors[i], stroke: palette.colors[i] });
            positionColorInput();
          });
          paletteEl.appendChild(sw);
        });

        const pickerBtn = document.createElement("div");
        pickerBtn.className = "swatch picker";
        pickerBtn.title = "Pick a color";
        pickerBtn.innerHTML = "<span>＋</span>";
        pickerBtn.addEventListener("click", () => {
          colorInput.value = normHex(palette.colors[palette.selected] || '#3b82f6');
          colorInput.click();
        });
        paletteEl.appendChild(pickerBtn);
      }

      function positionColorInput(){
        const plus = paletteEl.querySelector(".swatch.picker");
        if (!plus) return;
        const r = plus.getBoundingClientRect();
        Object.assign(colorInput.style, {
          left: (r.left) + "px",
          top:  (r.top)  + "px",
          width: r.width + "px",
          height:r.height+ "px",
          display: "block"
        });
      }

      colorInput.addEventListener("input", (e)=>{
        const val = normHex(e.target.value);
        const idx = palette.selected || 0;
        palette.colors[idx] = val;
        const sw = paletteEl.querySelectorAll(".swatch")[idx];
        if (sw) sw.style.background = val;
        if (lastHoverNode) restyleNodeWrapped(lastHoverNode, { fill: val, stroke: val });
        setStatus(`Preview color #${idx+1} → ${val}`);
      });

      colorInput.addEventListener("change", async (e)=>{
        const val = normHex(e.target.value);
        const idx = palette.selected || 0;
        palette.colors[idx] = val;
        await updateProjectMeta({ palette });
        renderPalette();
        setStatus(`Color saved #${idx+1} → ${val}`);
      });

      window.addEventListener("resize", positionColorInput);

      descCancelBtn.addEventListener("click", closeDescriptionModal);
      descSaveBtn.addEventListener("click", ()=>{
        if (!descNode) { closeDescriptionModal(); return; }
        setNodeDescription(descNode, descText.value);
        closeDescriptionModal();
      });

      descOverlay.addEventListener("pointerdown", (e)=>{
        if (e.target === descOverlay) closeDescriptionModal();
      });

      renameCancel.addEventListener("click", closeRenameModal);
      renameSave.addEventListener("click", ()=>{
        if (!renameNodeRef) { closeRenameModal(); return; }
        const val = (renameInput.value || "").trim();
        if (val) {
          renameNodeWrapped(renameNodeRef, val);
        }
        closeRenameModal();
      });

      renameInput.addEventListener("keydown", (e)=>{
        if (e.key === "Enter") {
          e.preventDefault();
          renameSave.click();
        }
        if (e.key === "Escape") {
          e.preventDefault();
          closeRenameModal();
        }
      });

      renameOverlay.addEventListener("pointerdown", (e)=>{
        if (e.target === renameOverlay) closeRenameModal();
      });

      // ----- Sidebar toggle -----
      let sidebarOpen = false;
      btnHelp.addEventListener("click", ()=>{
        sidebarOpen = !sidebarOpen;
        sidebar.style.display = sidebarOpen ? "flex" : "none";
      });
      btnHelp.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && sidebarOpen){ sidebarOpen=false; sidebar.style.display="none"; } });

      /* ----- Mobile UI behavior ----- */
      hamburger.addEventListener("click", ()=>{
        hambMenu.style.display = (hambMenu.style.display==="block") ? "none" : "block";
      });
      document.addEventListener("pointerdown", (e)=>{
        if (!hambMenu.contains(e.target) && e.target !== hamburger){
          hambMenu.style.display = "none";
        }
      });

      hambMenu.addEventListener("click", async (e)=>{
        const b = e.target.closest("button"); if (!b) return;
        const act = b.getAttribute("data-mobile");
        if (act==="open"){ await refreshProjectList(); gateOn(); setStatus("Open project"); }
        if (act==="new"){
          const name = prompt("New project name:"); if (!name || !name.trim()) return;
          try{ const p = await createProject(name.trim()); await refreshProjectList(); await openProject(p); }
          catch(err){ setStatus("Create failed (name exists?)"); }
        }
        if (act==="dup"){
          if (!currentProject){ setStatus("No project to duplicate"); return; }
          await persistSnapshot();
          const name = prompt(`Duplicate "${currentProject.name}" as:`); if (!name || !name.trim()) return;
          try{ const dup = await duplicateProject(currentProject.id, name.trim()); await refreshProjectList(); await openProject(dup); setStatus(`Duplicated as "${dup.name}"`); }
          catch(err){ setStatus("Duplicate failed (name exists?)"); }
        }
        if (act==="del"){
          if (!currentProject) return;
          const ok = confirm(`Delete project "${currentProject.name}"? This cannot be undone.`); if (!ok) return;
          await deleteProject(currentProject.id); await refreshProjectList(); gateOn();
        }
        if (act==="save"){
          await persistSnapshot();
        }
        if (act==="hint"){
          sidebarOpen = true; sidebar.style.display = "flex";
        }
        hambMenu.style.display = "none";
      });

      projectClose.addEventListener("click", () => {
        gateOff();
      });


      zoomInBtn.addEventListener("click", () => {
        applyZoomFactor(ZOOM_STEP);
      });

      zoomOutBtn.addEventListener("click", () => {
        applyZoomFactor(1 / ZOOM_STEP);
      });

      zoomResetBtn.addEventListener("click", () => {
        resetZoomTo100();
      });

      zoomFitBtn.addEventListener("click", () => {
        zoomToFit();
      });


      // Tool rail: Lines/Edit/Delete modes
      function syncToolButtons(){
        toolLines.classList.toggle("active",  linesMode);
        toolEdit.classList.toggle("active",   editMode);
        toolDelete.classList.toggle("active", deleteMode);
      }
      toolLines.addEventListener("click", ()=>{
        linesMode = !linesMode;
        if (!linesMode) chainFrom = null;
        if (linesMode){ editMode=false; deleteMode=false; }
        syncToolButtons();
        setStatus(linesMode ? "Lines mode: tap nodes to chain" : "Lines mode off");
      });
      toolEdit.addEventListener("click", ()=>{
        editMode = !editMode;
        if (editMode){ linesMode=false; chainFrom=null; deleteMode=false; }
        syncToolButtons();
        setStatus(editMode ? "Edit mode: tap a node for menu" : "Edit mode off");
      });
      toolDelete.addEventListener("click", ()=>{
        deleteMode = !deleteMode;
        if (deleteMode){ linesMode=false; chainFrom=null; editMode=false; }
        syncToolButtons();
        setStatus(deleteMode ? "Delete mode: tap a node to remove" : "Delete mode off");
      });
      syncToolButtons();

      // Node tap handler for Lines/Edit/Delete modes
      function handleNodePointerUp(e, node){
        if (tapMoved) return;
        if (!currentProject) return;
        if (deleteMode){
          deleteNodeWrapped(node);
          return;
        }

        if (linesMode){
          if (!chainFrom){
            chainFrom = node;
            selectedNodeId = node.id;
            updateNodeGraphics();
            setStatus(`Chain start: ${node.label}`);
            return;
          }
          if (chainFrom.id !== node.id){
            connectNodesWrapped(chainFrom.id, node.id);
            setStatus(`Linked ${chainFrom.label} → ${node.label}`);
          }
          chainFrom = node;
          selectedNodeId = node.id;
          updateNodeGraphics();
          return;
        }

        if (editMode){
          const fake = { preventDefault: ()=>{}, clientX: e.clientX, clientY: e.clientY };
          openMenu(fake, node);
          return;
        }
      }

      // Two-finger long-press to open menu (touch)
      let twoFingerTimer = null;
      function maybeTwoFingerMenu(e, node){
        if (!editMode && e.touches && e.touches.length===2){
          e.preventDefault();
          clearTwoFingerTimer();
          const t = e.touches[0];
          twoFingerTimer = setTimeout(()=>{
            const fake = { preventDefault: ()=>{}, clientX: t.clientX, clientY: t.clientY };
            openMenu(fake, node);
          }, LONG_PRESS_MS);
        }
      }
      function clearTwoFingerTimer(){ if (twoFingerTimer){ clearTimeout(twoFingerTimer); twoFingerTimer=null; } }

      // ----- Gate & boot -----
      function gateOn(){ gate.style.display = "flex"; gateCover.style.display = "block"; }
      function gateOff(){ gate.style.display = "none"; gateCover.style.display = "none"; }





      async function refreshProjectList(){
        const items = await listProjects();
        listEl.innerHTML = "";
        if (items.length===0){
          const d = document.createElement("div");
          d.className="proj-row";
          d.innerHTML = `<span class="proj-meta">No projects yet.</span>`;
          listEl.appendChild(d);
          return;
        }
        items.forEach(p=>{
          const row = document.createElement("div");
          row.className="proj-row";
          row.innerHTML = `
            <div>
              <div class="proj-name">${p.name}</div>
              <div class="proj-meta">Updated: ${new Date(p.updatedAt||p.createdAt).toLocaleString()}</div>
            </div>
            <div class="row-actions">
              <button class="btn primary" data-open="${p.id}">Open</button>
              <button class="btn" data-dup="${p.id}">Duplicate…</button>
              <button class="btn danger" data-del="${p.id}">Delete</button>
          </div>`;
          listEl.appendChild(row);
        });
        listEl.querySelectorAll("[data-open]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-open"));
          const all = await listProjects();
          const match = all.find(x=>x.id===id);
          if (!match) return; await openProject(match);
        }));
        listEl.querySelectorAll("[data-dup]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-dup"));
          const name = prompt("Name for the duplicate:");
          if (!name || !name.trim()) return;
          try{ const dup = await duplicateProject(id, name.trim()); await refreshProjectList(); await openProject(dup); setStatus(`Duplicated as "${dup.name}"`); }
          catch(err){ setStatus("Duplicate failed (name exists?)"); }
        }));
        listEl.querySelectorAll("[data-del]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-del"));
          await deleteProject(id); await refreshProjectList();
        }));
      }

      async function deleteProject(id){
        await new Promise((res,rej)=>{
          const t = tx(["projects","states","history"],"readwrite");
          t.objectStore("projects").delete(id);
          const s = t.objectStore("states").index("by_project").openCursor(IDBKeyRange.only(id));
          s.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("states").delete([id,c.value.rev]); c.continue(); } };
          const h = t.objectStore("history").index("by_project").openCursor(IDBKeyRange.only(id));
          h.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("history").delete([id,c.value.seq]); c.continue(); } };
          t.oncomplete=()=>res(); t.onerror=()=>rej(t.error);
        });
        if (currentProject && currentProject.id===id){ currentProject=null; gateOn(); clearGraph(); setStatus("Project deleted"); }
      }

      async function openProject(pMeta){
        currentProject = pMeta;
        projLabel.textContent = currentProject.name;
        palette = (pMeta.palette && Array.isArray(pMeta.palette.colors))
        ? { colors:[...pMeta.palette.colors], selected: Number(pMeta.palette.selected)||0 }
        : { colors:['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected:0 };
        renderPalette();

        const latest = await loadLatestState(currentProject.id);
        applyState(latest.state);
        await rebuildStacksFromHistory();
        gateOff();
        setStatus(`Project opened: ${currentProject.name} | Nodes: ${nodes.length} | Links: ${links.length}`);
      }

      btnSwitch.addEventListener("click", async ()=>{ await refreshProjectList(); gateOn(); setStatus("Open project"); });
      btnNew.addEventListener("click", async ()=>{
        const name = prompt("New project name:"); if (!name || !name.trim()) return;
        try{ const p = await createProject(name.trim()); await refreshProjectList(); await openProject(p); }catch(e){ setStatus("Create failed (name exists?)"); }
      });
      btnDup.addEventListener("click", async ()=>{
        if (!currentProject) { setStatus("No project to duplicate"); return; }
        await persistSnapshot();
        const name = prompt(`Duplicate "${currentProject.name}" as:`); 
        if (!name || !name.trim()) return;
        try {
          const dup = await duplicateProject(currentProject.id, name.trim());
          await refreshProjectList();
          await openProject(dup);
          setStatus(`Duplicated as "${dup.name}"`);
        } catch(e) {
          setStatus("Duplicate failed (name exists?)");
        }
      });
      btnDel.addEventListener("click", async ()=>{
        if (!currentProject) return;
        const ok = confirm(`Delete project "${currentProject.name}"? This cannot be undone.`); if (!ok) return;
        await deleteProject(currentProject.id); await refreshProjectList(); gateOn();
      });
      createBtn.addEventListener("click", async ()=>{
        const name = (projNameInput.value||"").trim(); if (!name) return;
        try{ const p = await createProject(name); projNameInput.value = ""; await refreshProjectList(); await openProject(p); }
        catch(e){ setStatus("Project create error (name exists?)"); }
      });

      btnUndo.addEventListener("click", doUndo);
      btnRedo.addEventListener("click", doRedo);
      btnSave.addEventListener("click", persistSnapshot);

      function clearGraph(){ nodes=[]; links=[]; nextId=1; renderAll(); projLabel.textContent="—"; }

      async function boot(){
        svg.style.touchAction = "none";
        db = await openDB();
        await refreshProjectList();
        gateOn();
        clearGraph();
        renderPalette();

        initViewBox();
        updateZoomLabel();

        requestAnimationFrame(positionColorInput);
        setStatus("Mode: create/open a project");

        // keep viewBox size in sync with viewport
        window.addEventListener("resize", () => {
          const rect = svg.getBoundingClientRect();
          const cx = viewBox.x + viewBox.w / 2;
          const cy = viewBox.y + viewBox.h / 2;

          const newW = rect.width  || viewBox.w;
          const newH = rect.height || viewBox.h;

          viewBox.w = newW;
          viewBox.h = newH;
          viewBox.x = cx - newW / 2;
          viewBox.y = cy - newH / 2;

          updateViewBox();
          positionColorInput();
        });



      }

      boot();
    })();
  </script>
</body>
</html>
