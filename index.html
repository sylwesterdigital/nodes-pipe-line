<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Node Editor — projects, persistence, history (IndexedDB)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg:#13141a; --panel:#1b1c25; --muted:#242633; --muted-2:#343647; --text:#e5e7eb; --acc:#3b82f6; --acc-2:#93c5fd;
      --pill:#0f172a; --pill-b:#334155; --shadow:rgba(0,0,0,.4);
    }
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; height: 100vh; display: flex; background:var(--bg); color:var(--text); user-select:none; }
    #sidebar { width: 280px; padding:16px; border-right:1px solid #2e2f3a; background:var(--panel); display:flex; flex-direction:column; gap:12px; }
    #sidebar h1 { font-size:18px; }
    #sidebar .hint { font-size:12px; line-height:1.5; padding:10px; border-radius:10px; background:var(--muted); border:1px solid var(--muted-2); }
    #canvas-wrapper { flex:1; position:relative; overflow:hidden; }
    #canvas { width:100%; height:100%; background: radial-gradient(circle at top left, #25273a 0, #151623 55%); }
    .node { cursor: grab; transition: transform 120ms ease; transform-box: fill-box; transform-origin: center; }
    .node:active { cursor: grabbing; }
    .node:hover { transform: scale(1.06); }
    .node text { fill:var(--text); font-size:11px; pointer-events:none; }
    .link { stroke:var(--text); stroke-width:2; stroke-linecap:round; }
    .link-shadow { stroke:rgba(0,0,0,0.6); stroke-width:4; stroke-linecap:round; }
    #temp-link { stroke:#fbbf24; stroke-width:2; stroke-dasharray:4 3; stroke-linecap:round; pointer-events:none; display:none; }
    #status { position:absolute; left:12px; bottom:12px; padding:6px 10px; border-radius:999px; background:rgba(15,23,42,0.88); border:1px solid rgba(148,163,184,0.5); font-size:11px; }
    #menu { position:absolute; min-width:180px; background:#0f172a; border:1px solid #334155; border-radius:10px; box-shadow:0 10px 30px var(--shadow); padding:6px; display:none; z-index:20; }
    #menu button { width:100%; text-align:left; padding:8px 10px; background:transparent; color:var(--text); border:none; border-radius:8px; font-size:13px; }
    #menu button:hover { background:#1f2937; }
    #menu .danger:hover { background:#3b1f27; color:#fecaca; }
    #menu hr { border:0; border-top:1px solid #334155; margin:6px 0; }

    /* Project gate */
    #project-gate {
      position: absolute; inset: 0; background: rgba(0,0,0,.6);
      display: none; align-items: center; justify-content: center; z-index: 30;
    }
    #project-card {
      width: min(620px, 92vw); background: var(--panel); border:1px solid var(--muted-2);
      border-radius: 14px; box-shadow: 0 20px 60px var(--shadow); padding: 16px; display:flex; flex-direction:column; gap:10px;
    }
    #project-card h2 { font-size:18px; margin-bottom:6px; }
    #projects-list { max-height: 260px; overflow:auto; border:1px solid var(--muted-2); border-radius:10px; padding:4px; }
    .proj-row { display:flex; align-items:center; justify-content:space-between; padding:8px; border-radius:8px; gap:10px; }
    .proj-row:hover { background: #222536; }
    .proj-name { font-size:14px; }
    .proj-meta { font-size:11px; opacity:.8; }
    .row-actions { display:flex; gap:8px; }
    .btn { appearance:none; border:1px solid var(--muted-2); background:var(--muted); color:var(--text); padding:6px 10px; border-radius:8px; font-size:12px; cursor:pointer; }
    .btn:hover { filter: brightness(1.1); }
    .btn.primary { background:#1f2a44; border-color:#2a3a5f; }
    .btn.danger { background:#3b1f27; border-color:#5b2531; color:#fecaca; }
    #project-form { display:flex; gap:8px; margin-top:8px; }
    #project-name { flex:1; padding:8px 10px; border-radius:8px; border:1px solid var(--muted-2); background:#0f1222; color:#e5e7eb; }

    #topbar {
      position:absolute; right:12px; top:12px; z-index:15; display:flex; gap:8px;
      background: var(--pill); border:1px solid var(--pill-b); padding:6px 8px; border-radius:999px; font-size:12px; align-items:center;
    }
    #topbar .label { opacity:.9; }
    #topbar .kbd { opacity:.8; border:1px solid var(--pill-b); padding:2px 6px; border-radius:6px; background:#0b1328; }
    #topbar .sep { opacity:.4; }

    /* Color palette (bottom-right) */
    #palette {
      position:absolute; right:12px; bottom:12px; z-index:15; display:flex; gap:8px;
      background: var(--pill); border:1px solid var(--pill-b); padding:6px 8px; border-radius:12px; align-items:center;
    }
    .swatch {
      width:18px; height:18px; border-radius:4px; border:1px solid rgba(255,255,255,.2); cursor:pointer; position:relative;
    }
    .swatch.selected { outline:2px solid #fff; outline-offset:2px; }
    .swatch.picker { display:grid; place-items:center; font-size:14px; width:22px; height:22px; border-radius:6px; }
    .swatch.picker span { pointer-events:none; }
    #palette input[type="color"]{ position:absolute; opacity:0; width:0; height:0; pointer-events:none; }

    .disabled-cover { position:absolute; inset:0; pointer-events:auto; }
  </style>
</head>
<body>
  <aside id="sidebar">
    <h1>Node Canvas</h1>
    <div class="hint">
      • Projects are required. Create, open, or duplicate a project to enable the canvas.<br>
      • Left-drag a node to move it (links follow).<br>
      • Right-click / two-finger tap / long-press a node for actions.<br>
      • “Start connection” → move (yellow guide) → click target node to connect.<br>
      • Undo/Redo: <strong>Ctrl/⌘+Z</strong> / <strong>Ctrl/⌘+Y</strong>.<br>
      • Quick-connect: hover a node and press <strong>N</strong>.<br>
      • Save: <strong>Ctrl/⌘+S</strong> · Delete hovered: <strong>X</strong> · Duplicate hovered: <strong>Shift+D</strong>.<br>
      • Palette: click color to select (white outline). The + swatch opens a color picker and updates the selected color for this project.
    </div>
  </aside>

  <div id="canvas-wrapper">
    <svg id="canvas">
      <g id="links-layer"></g>
      <line id="temp-link" x1="0" y1="0" x2="0" y2="0"></line>
      <g id="nodes-layer"></g>
    </svg>

    <div id="menu">
      <button data-action="connect">Start connection</button>
      <button data-action="rename">Rename…</button>
      <button data-action="duplicate">Duplicate</button>
      <hr>
      <button class="danger" data-action="delete">Delete</button>
    </div>

    <div id="topbar">
      <span class="label">Project:</span>
      <span id="proj-label" class="kbd">—</span>
      <span class="sep">|</span>
      <button id="btn-switch" class="btn">Open…</button>
      <button id="btn-new" class="btn">New…</button>
      <button id="btn-dup" class="btn">Duplicate…</button>
      <button id="btn-del" class="btn danger">Delete</button>
      <span class="sep">|</span>
      <button id="btn-undo" class="btn">Undo</button>
      <button id="btn-redo" class="btn">Redo</button>
      <span class="sep">|</span>
      <button id="btn-save" class="btn primary">Save</button>
    </div>

    <!-- palette mounts here dynamically -->
    <div id="palette"></div>

    <div id="status">Mode: create/open a project</div>

    <div id="project-gate">
      <div id="project-card">
        <h2>Projects</h2>
        <div id="projects-list"></div>
        <div id="project-form">
          <input id="project-name" placeholder="New project name" />
          <button id="create-project" class="btn primary">Create</button>
        </div>
      </div>
    </div>

    <div id="gate-cover" class="disabled-cover" style="display:none;"></div>
  </div>

  <script>
    (function () {
      // ---- Core refs ----
      const svg = document.getElementById("canvas");
      const nodesLayer = document.getElementById("nodes-layer");
      const linksLayer = document.getElementById("links-layer");
      const tempLink = document.getElementById("temp-link");
      const status = document.getElementById("status");
      const menu = document.getElementById("menu");
      const wrapper = document.getElementById("canvas-wrapper");

      const gate = document.getElementById("project-gate");
      const listEl = document.getElementById("projects-list");
      const projNameInput = document.getElementById("project-name");
      const createBtn = document.getElementById("create-project");
      const projLabel = document.getElementById("proj-label");

      const btnSwitch = document.getElementById("btn-switch");
      const btnNew    = document.getElementById("btn-new");
      const btnDup    = document.getElementById("btn-dup");
      const btnDel    = document.getElementById("btn-del");
      const btnUndo   = document.getElementById("btn-undo");
      const btnRedo   = document.getElementById("btn-redo");
      const btnSave   = document.getElementById("btn-save");
      const gateCover = document.getElementById("gate-cover");

      const paletteEl = document.getElementById("palette");

      // ---- Graph state (with styles) ----
      // node: {id, x, y, label, style:{shape:'circle'|'rect'|'triangle', fill, stroke}}
      // link: {from, to, style:{color}}
      let nodes = [], links = [], nextId = 1;

      // palette state (persisted in currentProject.meta)
      let palette = { colors: ['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected: 0 };

      let dragNode = null;
      let dragOffset = {x:0,y:0};
      let suppressClick = false;

      let linkingFrom = null;
      let menuNode = null;
      let lastHoverNode = null;

      let pressTimer = null;
      const LONG_PRESS_MS = 500;
      const DRAG_MENU_CANCEL_PX = 6;
      let downX = 0, downY = 0;

      // ---- Projects/History state ----
      let db = null;
      const DB_NAME = "node-editor";
      const DB_VER = 1;
      let currentProject = null;
      let undoStack = [];
      let redoStack = [];

      // ---- Utils ----
      function log(...a){ console.log("[nodes]", ...a); }
      function setStatus(text){ status.textContent = text; log(text); }
      function svgPoint(evt){ const pt = svg.createSVGPoint(); pt.x = evt.clientX; pt.y = evt.clientY; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }
      const selectedColor = ()=> palette.colors[palette.selected] || '#3b82f6';

      // ---- IndexedDB ----
      function openDB(){
        return new Promise((resolve, reject)=>{
          const req = indexedDB.open(DB_NAME, DB_VER);
          req.onupgradeneeded = (e)=>{
            const db = e.target.result;
            if (!db.objectStoreNames.contains("projects")) {
              const s = db.createObjectStore("projects", { keyPath: "id", autoIncrement: true });
              s.createIndex("by_name","name",{ unique: true });
            }
            if (!db.objectStoreNames.contains("states")) {
              const s2 = db.createObjectStore("states", { keyPath: ["projectId","rev"] });
              s2.createIndex("by_project","projectId");
            }
            if (!db.objectStoreNames.contains("history")) {
              const s3 = db.createObjectStore("history", { keyPath: ["projectId","seq"] });
              s3.createIndex("by_project","projectId");
            }
          };
          req.onsuccess = ()=> resolve(req.result);
          req.onerror = ()=> reject(req.error);
        });
      }
      function tx(storeNames, mode="readonly"){ return db.transaction(storeNames, mode); }

      // ---- Projects API ----
      async function listProjects(){
        const out = [];
        await new Promise((res,rej)=>{
          const t = tx(["projects"]);
          const req = t.objectStore("projects").openCursor();
          req.onsuccess = (e)=>{ const cur=e.target.result; if(cur){ out.push(cur.value); cur.continue(); } else res(); };
          req.onerror  = ()=>rej(req.error);
        });
        return out.sort((a,b)=> (b.updatedAt||b.createdAt||0) - (a.updatedAt||a.createdAt||0));
      }
      async function createProject(name){
        const now = Date.now();
        const meta = { name, createdAt: now, updatedAt: now, pointer: 0, palette };
        const t = tx(["projects"],"readwrite");
        const req = t.objectStore("projects").add(meta);
        const id = await new Promise((res,rej)=>{ req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); });
        await saveStateSnapshot(id, 0, { nodes:[], links:[], nextId:1 });
        await saveHistoryRecord(id, 1, { type:"INIT", at: now });
        return { id, ...meta };
      }
      async function duplicateProject(sourceId, newName){
        const now = Date.now();
        const t = tx(["projects"],"readwrite");
        // read source meta for palette copy
        const origin = await new Promise((res,rej)=>{
          const r = t.objectStore("projects").get(sourceId);
          r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);
        });
        const addReq = t.objectStore("projects").add({ name:newName, createdAt: now, updatedAt: now, pointer: 0, palette: origin?.palette || palette });
        const newId = await new Promise((res,rej)=>{ addReq.onsuccess=()=>res(addReq.result); addReq.onerror=()=>rej(addReq.error); });

        let maxRev = 0;
        await new Promise((res,rej)=>{
          const t2 = tx(["states"],"readwrite");
          const idx = t2.objectStore("states").index("by_project").openCursor(IDBKeyRange.only(sourceId));
          idx.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {rev,state}=c.value; maxRev=Math.max(maxRev,rev); t2.objectStore("states").put({projectId:newId,rev,state:JSON.parse(JSON.stringify(state))}); c.continue(); } else res(); };
          idx.onerror=()=>rej(idx.error);
        });
        await new Promise((res,rej)=>{
          const t3 = tx(["history"],"readwrite");
          const idx = t3.objectStore("history").index("by_project").openCursor(IDBKeyRange.only(sourceId));
          idx.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {seq,action}=c.value; t3.objectStore("history").put({projectId:newId,seq,action:JSON.parse(JSON.stringify(action))}); c.continue(); } else res(); };
          idx.onerror=()=>rej(idx.error);
        });
        await new Promise((res,rej)=>{
          const t4 = tx(["projects"],"readwrite");
          const putReq = t4.objectStore("projects").put({ id:newId, name:newName, createdAt: now, updatedAt: now, pointer: maxRev, palette: origin?.palette || palette });
          putReq.onsuccess=()=>res(); putReq.onerror=()=>rej(putReq.error);
        });
        return { id:newId, name:newName, createdAt: now, updatedAt: now, pointer: maxRev, palette: origin?.palette || palette };
      }
      async function updateProjectMeta(patch){
        if (!currentProject) return;
        const now = Date.now();
        const t = tx(["projects"],"readwrite");
        const obj = { ...currentProject, ...patch, updatedAt: now };
        await new Promise((res,rej)=>{ const r=t.objectStore("projects").put(obj); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
        currentProject = obj;
        projLabel.textContent = currentProject.name;
      }

      // ---- Snapshots / History ----
      async function saveStateSnapshot(projectId, rev, state){
        const t = tx(["states"],"readwrite");
        await new Promise((res,rej)=>{ const r=t.objectStore("states").put({projectId,rev,state}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
      }
      async function loadLatestState(projectId){
        let maxRev=-1, latest=null;
        await new Promise((res,rej)=>{
          const t = tx(["states"]);
          const idx = t.objectStore("states").index("by_project");
          const r = idx.openCursor(IDBKeyRange.only(projectId));
          r.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {rev,state}=c.value; if(rev>maxRev){maxRev=rev; latest={rev,state};} c.continue(); } else res(); };
          r.onerror=()=>rej(r.error);
        });
        return latest || { rev:0, state:{ nodes:[], links:[], nextId:1 } };
      }
      async function saveHistoryRecord(projectId, seq, action){
        const t = tx(["history"],"readwrite");
        await new Promise((res,rej)=>{ const r=t.objectStore("history").put({projectId,seq,action}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
      }
      async function loadHistory(projectId){
        const items=[];
        await new Promise((res,rej)=>{
          const t = tx(["history"]);
          const idx = t.objectStore("history").index("by_project");
          const r = idx.openCursor(IDBKeyRange.only(projectId));
          r.onsuccess=(e)=>{ const c=e.target.result; if(c){ items.push(c.value); c.continue(); } else res(); };
          r.onerror=()=>rej(r.error);
        });
        items.sort((a,b)=>a.seq-b.seq);
        return items;
      }

      // ---- Project UI ----
      async function refreshProjectList(){
        const items = await listProjects();
        listEl.innerHTML = "";
        if (items.length===0){
          const d = document.createElement("div");
          d.className="proj-row";
          d.innerHTML = `<span class="proj-meta">No projects yet.</span>`;
          listEl.appendChild(d);
          return;
        }
        items.forEach(p=>{
          const row = document.createElement("div");
          row.className="proj-row";
          row.innerHTML = `
            <div>
              <div class="proj-name">${p.name}</div>
              <div class="proj-meta">Updated: ${new Date(p.updatedAt||p.createdAt).toLocaleString()}</div>
            </div>
            <div class="row-actions">
              <button class="btn primary" data-open="${p.id}">Open</button>
              <button class="btn" data-dup="${p.id}">Duplicate…</button>
              <button class="btn danger" data-del="${p.id}">Delete</button>
          </div>`;
          listEl.appendChild(row);
        });
        listEl.querySelectorAll("[data-open]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-open"));
          const all = await listProjects();
          const match = all.find(x=>x.id===id);
          if (!match) return; await openProject(match);
        }));
        listEl.querySelectorAll("[data-dup]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-dup"));
          const name = prompt("Name for the duplicate:");
          if (!name || !name.trim()) return;
          try{ const dup = await duplicateProject(id, name.trim()); await refreshProjectList(); await openProject(dup); setStatus(`Duplicated as "${dup.name}"`); }
          catch(err){ setStatus("Duplicate failed (name exists?)"); }
        }));
        listEl.querySelectorAll("[data-del]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-del"));
          await deleteProject(id); await refreshProjectList();
        }));
      }

      async function deleteProject(id){
        await new Promise((res,rej)=>{
          const t = tx(["projects","states","history"],"readwrite");
          t.objectStore("projects").delete(id);
          const s = t.objectStore("states").index("by_project").openCursor(IDBKeyRange.only(id));
          s.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("states").delete([id,c.value.rev]); c.continue(); } };
          const h = t.objectStore("history").index("by_project").openCursor(IDBKeyRange.only(id));
          h.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("history").delete([id,c.value.seq]); c.continue(); } };
          t.oncomplete=()=>res(); t.onerror=()=>rej(t.error);
        });
        if (currentProject && currentProject.id===id){ currentProject=null; gateOn(); clearGraph(); setStatus("Project deleted"); }
      }

      async function openProject(pMeta){
        currentProject = pMeta;
        projLabel.textContent = currentProject.name;
        // hydrate palette from meta
        palette = (pMeta.palette && Array.isArray(pMeta.palette.colors))
        ? { colors:[...pMeta.palette.colors], selected: Number(pMeta.palette.selected)||0 }
        : { colors:['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected:0 };
        renderPalette();

        const latest = await loadLatestState(currentProject.id);
        applyState(latest.state);
        await rebuildStacksFromHistory();
        gateOff();
        setStatus(`Project opened: ${currentProject.name} | Nodes: ${nodes.length} | Links: ${links.length}`);
      }

      function gateOn(){ gate.style.display = "flex"; gateCover.style.display = "block"; }
      function gateOff(){ gate.style.display = "none"; gateCover.style.display = "none"; }

      // ---- Topbar actions ----
      btnSwitch.addEventListener("click", async ()=>{ await refreshProjectList(); gateOn(); setStatus("Open project"); });
      btnNew.addEventListener("click", async ()=>{
        const name = prompt("New project name:"); if (!name || !name.trim()) return;
        try{ const p = await createProject(name.trim()); await refreshProjectList(); await openProject(p); }catch(e){ setStatus("Create failed (name exists?)"); }
      });
      btnDup.addEventListener("click", async ()=>{
        if (!currentProject) { setStatus("No project to duplicate"); return; }
        const name = prompt(`Duplicate "${currentProject.name}" as:`); if (!name || !name.trim()) return;
        try{ const dup = await duplicateProject(currentProject.id, name.trim()); await refreshProjectList(); await openProject(dup); setStatus(`Duplicated as "${dup.name}"`); }catch(e){ setStatus("Duplicate failed (name exists?)"); }
      });
      btnDel.addEventListener("click", async ()=>{
        if (!currentProject) return;
        const ok = confirm(`Delete project "${currentProject.name}"? This cannot be undone.`); if (!ok) return;
        await deleteProject(currentProject.id); await refreshProjectList(); gateOn();
      });

      // ---- Form create inside gate ----
      createBtn.addEventListener("click", async ()=>{
        const name = (projNameInput.value||"").trim(); if (!name) return;
        try{ const p = await createProject(name); projNameInput.value = ""; await refreshProjectList(); await openProject(p); }
        catch(e){ setStatus("Project create error (name exists?)"); }
      });

      btnUndo.addEventListener("click", doUndo);
      btnRedo.addEventListener("click", doRedo);
      btnSave.addEventListener("click", persistSnapshot);

      // ---- History helpers ----
      function snapshot(){ return { nodes: JSON.parse(JSON.stringify(nodes)), links: JSON.parse(JSON.stringify(links)), nextId }; }
      function applyState(state){ nodes = JSON.parse(JSON.stringify(state.nodes||[])); links = JSON.parse(JSON.stringify(state.links||[])); nextId = state.nextId || 1; renderAll(); }
      async function pushAction(action){ if (!currentProject) return; undoStack.push(snapshot()); redoStack.length = 0; await appendHistory(action); updateProjectMeta({}); }
      async function appendHistory(action){ const all = await loadHistory(currentProject.id); const nextSeq = (all.length? all[all.length-1].seq+1 : 1); await saveHistoryRecord(currentProject.id, nextSeq, action); }
      async function rebuildStacksFromHistory(){ undoStack.length=0; redoStack.length=0; undoStack.push(snapshot()); }
      async function doUndo(){ if (!currentProject || undoStack.length<=1) return; const cur=undoStack.pop(); redoStack.push(cur); const prev=undoStack[undoStack.length-1]; applyState(prev); setStatus("Undo"); await persistSnapshot(); }
      async function doRedo(){ if (!currentProject || !redoStack.length) return; const nxt=redoStack.pop(); undoStack.push(nxt); applyState(nxt); setStatus("Redo"); await persistSnapshot(); }
      async function persistSnapshot(){ if (!currentProject) return; const latest=await loadLatestState(currentProject.id); const newRev=latest.rev+1; await saveStateSnapshot(currentProject.id,newRev,snapshot()); await updateProjectMeta({pointer:newRev, palette}); setStatus(`Saved rev ${newRev}`); }

      // ---- Graph CRUD (history-wrapped) ----
      function makeDefaultStyle(){ const c = selectedColor(); return { shape:'circle', fill:c, stroke:c }; }
      function addNodeWrapped(x,y){
        const node={id:nextId++,x,y,label:"N"+(nextId-1), style: makeDefaultStyle()};
        nodes.push(node); renderNodes(); renderLinks(); pushAction({type:"ADD_NODE",at:Date.now(),node});
      }
      function moveNodeWrapped(node){ renderLinks(); pushAction({type:"MOVE_NODE",at:Date.now(),id:node.id,x:node.x,y:node.y}); }
      function deleteNodeWrapped(node){ nodes=nodes.filter(n=>n.id!==node.id); links=links.filter(l=>l.from!==node.id&&l.to!==node.id); renderAll(); pushAction({type:"DELETE_NODE",at:Date.now(),id:node.id}); }
      function duplicateNodeWrapped(node, keepLabel=false){
        const newLabel = keepLabel ? (node.label ? node.label + "1" : "N"+nextId) : ("N"+nextId);
        const n2={ id:nextId++, x:node.x+28, y:node.y+28, label:newLabel, style: JSON.parse(JSON.stringify(node.style||makeDefaultStyle())) };
        nodes.push(n2); renderAll(); pushAction({type:"DUPLICATE_NODE",at:Date.now(),from:node.id,to:n2.id});
      }
      function connectNodesWrapped(aId,bId){ links.push({from:aId,to:bId, style:{color:selectedColor()}}); renderLinks(); pushAction({type:"CONNECT",at:Date.now(),from:aId,to:bId,color:selectedColor()}); }
      function renameNodeWrapped(node,newLabel){ const old=node.label; node.label=newLabel; updateNodeGraphics(node); pushAction({type:"RENAME_NODE",at:Date.now(),id:node.id,from:old,to:newLabel}); }
      function restyleNodeWrapped(node, patch){
        node.style = { ...(node.style||makeDefaultStyle()), ...patch };
        updateNodeGraphics(node);
        pushAction({type:"STYLE_NODE", at:Date.now(), id:node.id, patch});
      }

      // ---- Connection helper ----
      function startConnectionFrom(node){
        if (!node) return;
        linkingFrom = node;
        tempLink.setAttribute("x1", node.x);
        tempLink.setAttribute("y1", node.y);
        tempLink.setAttribute("x2", node.x);
        tempLink.setAttribute("y2", node.y);
        tempLink.style.display = "block";
        svg.addEventListener("mousemove", onCanvasMouseMove);
        setStatus(`Connecting from ${node.label}: move cursor, click another node to finish`);
      }

      // ---- Rendering (shapes & colors) ----
      function renderNodes() {
        nodesLayer.innerHTML = "";
        nodes.forEach(node => {
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.classList.add("node");
          g.dataset.id = String(node.id);

          const style = node.style || makeDefaultStyle();
          let shapeEl;
          if (style.shape === 'rect') {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            shapeEl.setAttribute("x", node.x - 18); shapeEl.setAttribute("y", node.y - 18);
            shapeEl.setAttribute("width", 36); shapeEl.setAttribute("height", 36); shapeEl.setAttribute("rx", 6);
          } else if (style.shape === 'triangle') {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            const p1 = `${node.x},${node.y-20}`, p2 = `${node.x-18},${node.y+16}`, p3 = `${node.x+18},${node.y+16}`;
            shapeEl.setAttribute("points", `${p1} ${p2} ${p3}`);
          } else {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            shapeEl.setAttribute("cx", node.x); shapeEl.setAttribute("cy", node.y); shapeEl.setAttribute("r", 18);
          }
          shapeEl.setAttribute("fill", style.fill); shapeEl.setAttribute("stroke", style.stroke); shapeEl.setAttribute("stroke-width","2");

          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", node.x); text.setAttribute("y", node.y + 4); text.setAttribute("text-anchor", "middle");
          text.textContent = node.label;

          g.appendChild(shapeEl); g.appendChild(text); nodesLayer.appendChild(g);

          g.addEventListener("mouseenter", ()=>{ lastHoverNode = node; });
          g.addEventListener("mouseleave", ()=>{ if (lastHoverNode && lastHoverNode.id===node.id) lastHoverNode=null; });

          g.addEventListener("mousedown", (e)=>onNodeMouseDown(e, node));
          g.addEventListener("mouseup", onNodeMouseUp);
          g.addEventListener("mouseleave", onNodeMouseLeave);
          g.addEventListener("contextmenu", (e)=>openMenu(e, node));
          g.addEventListener("mousedown", (e)=>startPressTimer(e, node));
          g.addEventListener("mouseup", cancelPressTimer);
          g.addEventListener("mouseleave", cancelPressTimer);
        });
        setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
      }
      function renderLinks() {
        linksLayer.innerHTML = "";
        links.forEach(link => {
          const from = nodes.find(n => n.id === link.from);
          const to   = nodes.find(n => n.id === link.to);
          if (!from || !to) return;

          const shadow = document.createElementNS("http://www.w3.org/2000/svg", "line");
          shadow.classList.add("link-shadow");
          shadow.setAttribute("x1", from.x); shadow.setAttribute("y1", from.y);
          shadow.setAttribute("x2", to.x);   shadow.setAttribute("y2", to.y);

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.classList.add("link");
          line.setAttribute("x1", from.x); line.setAttribute("y1", from.y);
          line.setAttribute("x2", to.x);   line.setAttribute("y2", to.y);
          if (link.style && link.style.color) line.setAttribute("stroke", link.style.color);

          linksLayer.appendChild(shadow);
          linksLayer.appendChild(line);
        });
        setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
      }
      function renderAll(){ renderNodes(); renderLinks(); }

      // ✅ FIX: define updateNodeGraphics used by rename/style
      function updateNodeGraphics(/* node */){
        // simple, safe re-render of everything; swap with targeted updates later if needed
      renderAll();
    }

      // ---- Context menu ----
    function openMenu(e, node){
      if (linkingFrom || dragNode) return;
      e.preventDefault();
      closeMenu();
      menuNode = node;
      const rect = wrapper.getBoundingClientRect();
      const x = Math.min(e.clientX - rect.left, rect.width - 200);
      const y = Math.min(e.clientY - rect.top,  rect.height - 160);
      menu.style.left = x + "px";
      menu.style.top  = y + "px";
      menu.style.display = "block";
    }
    function closeMenu(){ menu.style.display = "none"; menuNode = null; }

    menu.addEventListener("click", (e)=>{
      const btn = e.target.closest("button");
      if (!btn || !menuNode) return;
      const action = btn.dataset.action;
      if (action === "connect") startConnectionFrom(menuNode);
      if (action === "rename") {
        const val = prompt("New name:", menuNode.label);
        if (val && val.trim()) { renameNodeWrapped(menuNode, val.trim()); }
      }
      if (action === "duplicate") { duplicateNodeWrapped(menuNode, true); }
      if (action === "delete") { deleteNodeWrapped(menuNode); }
      closeMenu();
    });

    wrapper.addEventListener("mousedown", (e)=>{ if (e.target === svg) closeMenu(); });

      // ---- Keyboard shortcuts ----
    window.addEventListener("keydown", async (e)=>{
      const mod = e.ctrlKey || e.metaKey;
      const k = e.key.toLowerCase();

      if (mod && k==="s"){ e.preventDefault(); await persistSnapshot(); return; }
      if (mod && k==="z"){ e.preventDefault(); await doUndo(); return; }
      if (mod && k==="y"){ e.preventDefault(); await doRedo(); return; }
      if (k==="escape"){ closeMenu(); cancelLinking("esc"); return; }

      if (!currentProject) return;

      if (k==="n"){ if (!linkingFrom && lastHoverNode){ closeMenu(); startConnectionFrom(lastHoverNode); } }
      if (k==="x"){ if (lastHoverNode){ deleteNodeWrapped(lastHoverNode); } }
      if (e.shiftKey && k==="d"){ if (lastHoverNode){ duplicateNodeWrapped(lastHoverNode, true); } }
    });

      // ---- Palette rendering & events ----
    function renderPalette(){
      paletteEl.innerHTML = "";
        // 4 color swatches
      palette.colors.slice(0,4).forEach((c, i)=>{
        const sw = document.createElement("div");
        sw.className = "swatch" + (palette.selected===i ? " selected" : "");
        sw.style.background = c;
        sw.dataset.index = String(i);
        sw.addEventListener("click", ()=>{
          palette.selected = i;
          renderPalette();
            updateProjectMeta({ palette }); // persist selection immediately
            if (lastHoverNode) restyleNodeWrapped(lastHoverNode, { fill: selectedColor(), stroke: selectedColor() });
          });
        paletteEl.appendChild(sw);
      });

        // 5th swatch: color picker button
      const picker = document.createElement("div");
      picker.className = "swatch picker";
      picker.style.background = "#0b1328";
      picker.title = "Pick a color (replaces selected swatch)";
      picker.innerHTML = `<span>＋</span>`;
      const input = document.createElement("input");
      input.type = "color";
      input.value = selectedColor();
      picker.addEventListener("click", ()=> input.click());
      input.addEventListener("input", ()=>{
        const idx = palette.selected || 0;
        palette.colors[idx] = input.value;
        renderPalette();
        updateProjectMeta({ palette });
        setStatus(`Updated palette color #${idx+1} → ${input.value}`);
      });
      picker.appendChild(input);
      paletteEl.appendChild(picker);
    }

      // ---- Long-press ----
    function startPressTimer(e, node){
      if (e.button !== 0 || linkingFrom) return;
      cancelPressTimer();
      downX = e.clientX; downY = e.clientY;
      pressTimer = setTimeout(()=>{ suppressClick = true; openMenu(e, node); }, LONG_PRESS_MS);
    }
    function cancelPressTimer(){ if (pressTimer){ clearTimeout(pressTimer); pressTimer=null; } }
    function onNodeMouseUp(){ cancelPressTimer(); }
    function onNodeMouseLeave(){ cancelPressTimer(); }

      // ---- Drag & move ----
    function onNodeMouseDown(e, node){
      if (!currentProject){ gateOn(); return; }
      if (linkingFrom){
        e.preventDefault();
        if (node.id !== linkingFrom.id) { connectNodesWrapped(linkingFrom.id, node.id); }
        cancelLinking("completed");
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      if (suppressClick || e.button !== 0) return;

      const p = svgPoint(e);
      dragNode = node;
      dragOffset.x = node.x - p.x;
      dragOffset.y = node.y - p.y;

      svg.addEventListener("mousemove", onCanvasMouseMove);
      svg.addEventListener("mouseup", onCanvasMouseUp);
      setStatus(`Dragging ${node.label}`);
    }

    function onCanvasMouseMove(e){
      if (pressTimer && dist(e.clientX,e.clientY,downX,downY) > DRAG_MENU_CANCEL_PX) cancelPressTimer();

      if (linkingFrom){
        const p = svgPoint(e);
        tempLink.setAttribute("x2", p.x);
        tempLink.setAttribute("y2", p.y);
        return;
      }
      if (!dragNode) return;
      const p = svgPoint(e);
      dragNode.x = p.x + dragOffset.x;
      dragNode.y = p.y + dragOffset.y;
      renderAll();
    }

    function onCanvasMouseUp(){
      svg.removeEventListener("mousemove", onCanvasMouseMove);
      svg.removeEventListener("mouseup", onCanvasMouseUp);
      if (dragNode){ moveNodeWrapped(dragNode); dragNode = null; }
      suppressClick = false;
    }

      // ---- Complete connection on mouseup ----
    nodesLayer.addEventListener("mouseup", (e)=>{
      if (!linkingFrom) return;
      const group = e.target.closest(".node");
      if (!group) return;
      const toId = Number(group.dataset.id);
      if (toId !== linkingFrom.id) { connectNodesWrapped(linkingFrom.id, toId); }
      cancelLinking("completed-mouseup");
    });

      // ---- Canvas add-node / cancel linking ----
    svg.addEventListener("mousedown", (e)=>{
      if (e.button === 2) e.preventDefault();
      if (e.target !== svg) return;
      if (!currentProject){ gateOn(); return; }
      if (linkingFrom){ cancelLinking("empty-click"); setStatus("Link cancelled"); return; }
      const p = svgPoint(e);
      addNodeWrapped(p.x, p.y);
    });

    function cancelLinking(){
      if (!linkingFrom) return;
      linkingFrom = null;
      tempLink.style.display = "none";
      svg.removeEventListener("mousemove", onCanvasMouseMove);
    }

      // ---- Prevent context menu while dragging/linking ----
    nodesLayer.addEventListener("contextmenu", (e)=>{
      if (dragNode || linkingFrom){ e.preventDefault(); e.stopPropagation(); }
    });
    svg.addEventListener("contextmenu", (e)=>e.preventDefault());

      // ---- Boot ----
    async function boot(){ db = await openDB(); await refreshProjectList(); gateOn(); clearGraph(); renderPalette(); }
    function clearGraph(){ nodes=[]; links=[]; nextId=1; renderAll(); projLabel.textContent="—"; }

    boot();
    setStatus("Mode: create/open a project");
  })();
</script>
</body>
</html>
