<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">


  <meta name="theme-color" content="#13141a">
  <link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;Node Canvas&quot;,&quot;display&quot;:&quot;standalone&quot;}">
  <title>Node Editor — projects, persistence, history (IndexedDB)</title>


  <style>
    /* Base + mobile hygiene */
    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { height:100%; }


    :root{
      --bg:#13141a;
      --panel:#1b1c25;
      --muted:#242633;
      --muted-2:#343647;
      --text:#e5e7eb;
      --kbd:#8bc34a;
      --pill:#0f172a;
      --pill-b:#334155;
      --shadow:rgba(0,0,0,.4);
      --fs:16px;

      /* menus / popovers */
      --menu-bg:#0f172a;
      --menu-border:#334155;
      --menu-hover:#1f2937;

      /* project list rows */
      --row-hover-bg:#222536;
    }




    * { -webkit-tap-highlight-color: transparent; -webkit-user-select: none; user-select: none; }
    body { overscroll-behavior: none; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      font-size: var(--fs);
      background:var(--bg);
      color:var(--text);
      height:100vh; display:flex;
    }

    input, textarea {
      font-size:16px;
    }

    button {
      touch-action: manipulation;
    }

    /* Sidebar */
    #sidebar {
      width:min(340px, 88vw);
      padding:16px; border-right:1px solid #2e2f3a; background:var(--panel);
      display:none; flex-direction:column; gap:12px;
      position:absolute; z-index:40; left:12px; top:60px;
      border-radius:12px; box-shadow:0 20px 60px var(--shadow);
    }
    #sidebar h1 { font-size:18px; }
    #sidebar .hint { font-size:16px; line-height:1.5; padding:10px; border-radius:10px; background:var(--muted); border:1px solid var(--muted-2); }

    /* Canvas area */
    #canvas-wrapper { flex:1; position:relative; overflow:hidden; }
    #canvas { width:100%; height:100%; background: radial-gradient(circle at top left, #25273a 0, #151623 55%); }
    #canvas, .node { touch-action:none; }

    .node { cursor: grab; transition: transform 120ms ease; transform-box: fill-box; transform-origin: center; }
    .node:active { cursor: grabbing; }
    .node:hover { transform: scale(1.06); }
    .node text { fill:var(--text); font-size:16px; pointer-events:none; }

    .link { stroke:var(--text); stroke-width:2; stroke-linecap:round; }
    .link-shadow { stroke:rgba(0,0,0,0.6); stroke-width:4; stroke-linecap:round; }
    #temp-link { stroke:#fbbf24; stroke-width:2; stroke-dasharray:4 3; stroke-linecap:round; pointer-events:none; display:none; }

    #status {
      position:absolute;
      transform: translateX(-50%);
      left: 50%;
      top: 60px;
      bottom:auto;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(15,23,42,0.88);
      border:1px solid rgba(148,163,184,0.5);
      font-size:12px;
      pointer-events: none;
    }

    #menu {
      position:absolute;
      min-width:200px;
      background:var(--menu-bg);
      border:1px solid var(--menu-border);
      border-radius:10px;
      box-shadow:0 10px 30px var(--shadow);
      padding:6px;
      display:none;
      z-index:20;
    }
    #menu button {
      width:100%;
      text-align:left;
      padding:10px 12px;
      background:transparent;
      color:var(--text);
      border:none;
      border-radius:8px;
      font-size:16px;
    }
    #menu button:hover { background:var(--menu-hover); }
    #menu .danger:hover { background:#f44336; color:#fecaca; }
    #menu hr {
      border:0;
      border-top:1px solid var(--menu-border);
      margin:6px 0;
    }

    /* Topbar */
    #topbar {
      position: absolute; right: 12px; top: 12px; z-index: 35;
      display: flex; gap: 8px; background: none; border: 0px solid var(--pill-b);
      padding: 0; border-radius: 0px; font-size: 14px; align-items: center;
    }
    #topbar .label, #topbar .kbd, #topbar .sep { display:none; }

    .kbd {
      color: var(--kbd);
    }

    .btn {
      appearance: none; border: 1px solid var(--muted-2); background: var(--muted);
      color: var(--text); padding: 8px 12px; border-radius: 10px; font-size: 16px; cursor: pointer;
    }
    .btn:hover { filter: brightness(1.06); }
    .btn.primary { background:#1f2a44; border-color:#2a3a5f; }
    .btn.danger  { background:#f44336; border-color:#5b2531; color:#fecaca; }

    #btn-help, #btn-switch, #btn-new { display:inline-flex; align-items:center; justify-content:center; min-width:44px; }

    /* Only hide dup/del by default */
    #btn-dup,
    #btn-del {
      display:none;
    }

    @media (min-width: 768px) {
      #topbar .label,
      #topbar .kbd,
      #topbar .sep { display:inline; }

      #btn-dup,
      #btn-del {
        display:inline-flex;
      }
    }

    /* Palette */
    #palette {
      position:absolute; right:12px; bottom:12px; z-index:15; display:flex; gap:10px;
      background: var(--pill); border:1px solid var(--pill-b); padding:8px 10px; border-radius:12px; align-items:center;
    }
    .swatch { width:28px; height:28px; border-radius:6px; border:1px solid rgba(255,255,255,.2); cursor:pointer; position:relative; }
    .swatch.selected { outline:2px solid #fff; outline-offset:2px; }
    .swatch.picker { display:grid; place-items:center; font-size:18px; width:32px; height:32px; border-radius:8px; }
    .swatch.picker span { pointer-events:none; }

    /* Invisible color-input exactly on top of the ＋ swatch */
    #palette-color-input {
      position: fixed;
      left: 0;
      top: 0;
      width: 32px;
      height: 32px;
      opacity: 0;
      border: none;
      padding: 0;
      margin: 0;
      background: transparent;
      z-index: 100;
    }

    .disabled-cover { position:absolute; inset:0; pointer-events:auto; }

    /* Project gate modal */
    #project-gate{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.6); z-index:50;
    }
    #project-card{
      width:min(620px,92vw); background:var(--panel); border:1px solid var(--muted-2);
      border-radius:14px; box-shadow:0 20px 60px var(--shadow); padding:16px; display:flex; flex-direction:column; gap:10px;
    }
    #project-card h2{ font-size:18px; margin-bottom:6px; }


    /* Project list (scrollable, hidden scrollbar) */
    #projects-list{
      max-height:260px;
      overflow:auto;
      border:1px solid var(--muted-2);
      border-radius:10px;
      padding:4px;
      background:var(--bg);

      /* hide scrollbar, keep scroll */
      -ms-overflow-style:none;  /* IE / Edge */
      scrollbar-width:none;     /* Firefox */
    }
    #projects-list::-webkit-scrollbar{
      display:none;             /* Chrome / Safari */
    }

    .proj-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px;
      border-radius:8px;
      gap:10px;
    }
    .proj-row:hover{
      background:var(--row-hover-bg);
    }
    .proj-name{
      font-size:16px;
    }
    .proj-meta{
      font-size:12px;
      opacity:.8;
    }
    .row-actions{
      display:flex;
      gap:8px;
    }





    #project-form{ display:flex; gap:8px; margin-top:8px; }
    #project-name{
      flex:1; padding:10px 12px; border-radius:8px; border:1px solid var(--muted-2);
      background:#0f1222; color:#e5e7eb; font-size:16px;
    }

    .project-card-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }

    .project-close-btn{
      min-width:auto;
      padding:4px 10px;
      line-height:1;
      font-size:16px;
    }

    /* Mobile UI additions */
    #hamburger{
      position:absolute;
      right:12px;
      top:12px;
      z-index:40;
      background:var(--pill);
      border:1px solid var(--pill-b);
      border-radius:10px;
      width:44px;
      height:44px;
      display:grid;
      place-items:center;
      color: var(--text);  
    }
    #hamburger span{
      font-size:20px;
      line-height:1;
      color: inherit;  
    }

    #hamburger-menu{
      position:absolute;
      right:12px;
      top:60px;
      z-index:41;
      background:var(--menu-bg);
      border:1px solid var(--menu-border);
      border-radius:12px;
      box-shadow:0 12px 30px var(--shadow);
      display:none;
      min-width:200px;
      overflow:hidden;
    }
    #hamburger-menu button{
      width:100%;
      padding:12px 14px;
      background:transparent;
      border:0;
      color:var(--text);
      text-align:left;
      font-size:16px;
    }
    #hamburger-menu button:hover{
      background:var(--menu-hover);
    }


    #mobile-undo-redo{
      position:absolute;
      right:12px;
      bottom:72px;
      z-index:40;
      display:flex;
      gap:8px;
      padding:6px;
    }

    @media(min-width:768px){
      #hamburger,
      #hamburger-menu{
        display:none;
      }
    }

    #tool-rail{
      position:absolute;
      left:12px;
      top:68px;
      bottom:12px;
      width:56px;
      z-index:38;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:none;
    }

    #tool-rail .tool{
      pointer-events:auto;
    }

    .tool{
      flex:0 0 auto;
      display:grid;
      place-items:center;
      height:44px;
      border-radius:10px;
      border:1px solid var(--muted-2);
      background:var(--muted);
      font-size:12px;
      color:#ffffff;
    }
    .tool.active{outline:2px solid #fff;outline-offset:2px}
    .tool .lbl{
      pointer-events:none;
      font-size:11px;
      color:#ffffff;
    }

    /* Node description overlay */
    #desc-overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.65);
      z-index:70;
      padding:16px;
    }

    #desc-card{
      width:min(640px, 96vw);
      max-height:80vh;
      background:var(--panel);
      border:1px solid var(--muted-2);
      border-radius:14px;
      box-shadow:0 24px 80px var(--shadow);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
    }

    #desc-card h2{
      font-size:18px;
    }

    #desc-node-label{
      font-size:16px;
      opacity:.8;
    }

    #desc-text{
      width:100%;
      min-height:120px;
      max-height:40vh;
      resize:vertical;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--muted-2);
      background:var(--bg);      /* theme-aware background */
      color:var(--text);         /* theme-aware text */
      font-size:16px;
      line-height:1.4;
    }

    .desc-actions{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-top:4px;
    }

    /* Rename node overlay */
    #rename-overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.65);
      z-index:71;
      padding:16px;
    }

    #rename-card{
      width:min(480px, 90vw);
      background:var(--panel);
      border:1px solid var(--muted-2);
      border-radius:14px;
      box-shadow:0 24px 80px var(--shadow);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    #rename-card h2{
      font-size:18px;
    }

    /* Rename node input */
    #rename-input{
      width:100%;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--muted-2);
      background:var(--bg);      
      color:var(--text);
      font-size:16px;
    }




    @media (max-width: 767px) {
      #topbar { display:none; }
    }

    #zoom-controls{
      position:absolute;
      left:12px;
      bottom: 12px;
      z-index:40;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      font-size:14px;
    }

    #zoom-controls .btn{
      min-width:40px;
      padding:6px 10px;
    }

    #zoom-reset {
      font-size: 12px;
    }

    #zoom-controls #zoom-label{
      min-width:auto;
      margin:2px 0;
      font-size:13px;
      text-align:center;
    }



    /* Light theme */
    :root[data-theme="light"]{
      --bg:#f9fafb;
      --panel:#ffffff;
      --muted:#e5e7eb;
      --muted-2:#d1d5db;
      --text:#111827;
      --pill:#e5e7eb;
      --pill-b:#cbd5e1;
      --shadow:rgba(15,23,42,0.15);

      /* menus / popovers */
      --menu-bg:#ffffff;
      --menu-border:#cbd5e1;
      --menu-hover:#e5e7eb;

      /* project list rows */
      --row-hover-bg:#e5e7eb;
    }



    :root[data-theme="light"] #canvas{
      background: radial-gradient(circle at top left,#e5e7eb 0,#f3f4f6 55%);
    }

    :root[data-theme="light"] #status{
      color:#f9fafb;
    }

    :root[data-theme="light"] .btn.primary{
      background:#1d4ed8;
      border-color:#1d4ed8;
      color:#f9fafb;
    }

    :root[data-theme="light"] .tool{
      background:var(--muted);
      border-color:var(--muted-2);
      color:#111827;
    }

    :root[data-theme="light"] .tool .lbl{
      color:#111827;
    }

    /* Config overlay */
    #config-overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.65);
      z-index:72;
      padding:16px;
    }

    #config-card{
      width:min(640px,96vw);
      max-height:80vh;
      background:var(--panel);
      border:1px solid var(--muted-2);
      border-radius:14px;
      box-shadow:0 24px 80px var(--shadow);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow:auto;
    }

    #config-card h2{
      font-size:18px;
    }

    #config-card h3{
      font-size:16px;
      margin-bottom:4px;
    }

    .config-section{
      border-radius:10px;
      padding:10px;
      background:var(--muted);
      border:1px solid var(--muted-2);
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    .config-row{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }

    .config-note{
      font-size:13px;
      opacity:.8;
    }

    .config-import-modes label{
      font-size:14px;
      display:flex;
      align-items:center;
      gap:4px;
    }

/* Dialog overlay */
#dialog-overlay{
  position:absolute;
  inset:0;
  display:none;
  align-items:flex-end;
  justify-content:center;
  background:rgba(0,0,0,.55);
  z-index:80;
  padding:12px;
}

#dialog-card{
  width:100%;
  max-width:480px;
  margin-bottom:4px;
  background:var(--panel);
  border-radius:18px 18px 0 0;
  border:1px solid var(--muted-2);
  box-shadow:0 16px 40px var(--shadow);
  padding:16px 16px 10px;
  display:flex;
  flex-direction:column;
  gap:12px;
}

@media (min-width:768px){
  #dialog-overlay{
    align-items:center;
  }
  #dialog-card{
    max-width:420px;
    border-radius:14px;
    margin-bottom:0;
  }
}

#dialog-title{
  font-size:17px;
  font-weight:600;
  text-align:center;
}

#dialog-message{
  font-size:15px;
  line-height:1.4;
  text-align:center;
  white-space:pre-wrap;
}

#dialog-input{
  margin-top:4px;
  width:100%;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid var(--muted-2);
  background:var(--bg);      
  color:var(--text);
  font-size:16px;
}

.dialog-actions{
  margin-top:8px;
  display:flex;
  flex-direction:column;
  gap:8px;
}

.dialog-actions .btn{
  width:100%;
  justify-content:center;
  font-size:16px;
  padding:12px;
}

/* Layout bottom sheet */
#layout-overlay{
  position:absolute;
  inset:0;
  display:none;
  align-items:flex-end;
  justify-content:center;
  background:rgba(0,0,0,.55);
  z-index:79;
  padding:12px;
}

#layout-card{
  width:100%;
  max-width:480px;
  margin-bottom:4px;
  background:var(--panel);
  border-radius:18px 18px 0 0;
  border:1px solid var(--muted-2);
  box-shadow:0 16px 40px var(--shadow);
  padding:16px 16px 12px;
  display:flex;
  flex-direction:column;
  gap:10px;
}

@media (min-width:768px){
  #layout-overlay{
    align-items:center;
  }
  #layout-card{
    max-width:420px;
    border-radius:14px;
    margin-bottom:0;
  }
}

#layout-title{
  font-size:17px;
  font-weight:600;
  text-align:center;
}

#layout-message{
  font-size:14px;
  line-height:1.4;
  text-align:center;
  opacity:.9;
}

#layout-list{
  margin-top:4px;
  display:flex;
  flex-direction:column;
  gap:8px;
}

#layout-list .btn{
  width:100%;
  justify-content:center;
  font-size:16px;
  padding:10px 12px;
}

.layout-actions{
  margin-top:6px;
  display:flex;
  justify-content:center;
}






</style>


<script>
  if (navigator.onLine) {
    const s = document.createElement('script');
    s.src = 'https://analytics.mielniczuk.com/script.js';
    s.defer = true;
    s.dataset.websiteId = '3a699de2-3ece-40f4-bc5c-5934996109e5';
    document.head.appendChild(s);
  }
</script>


</head>
<body>


  <aside id="sidebar">
    <h1>Node Canvas</h1>
    <div class="hint">
      • Create/open a project to enable the canvas.<br>
      • Drag a node to move it (links follow). Long-press a node for actions.<br>
      • Desktop: hover a node and press N to start a link.<br>
      • Touch: start connection, touch canvas to begin guide, lift on target node.<br>
      • Undo/Redo: Ctrl/⌘+Z / Ctrl/⌘+Y (desktop). Save: Ctrl/⌘+S.<br>
      • Create node: click/tap empty canvas (not on an existing node).<br>
      • Mobile: use the left tool rail (Lines/Edit/Delete) to change tap behavior.
      • Pan canvas: hold Space and drag, or drag with the middle mouse button on empty canvas.<br>
      • Mobile: drag with two fingers on empty canvas to pan the canvas.<br>

    </div>
  </aside>


  <div id="dialog-overlay">
    <div id="dialog-card">
      <h2 id="dialog-title"></h2>
      <p id="dialog-message"></p>
      <input id="dialog-input" />
      <div class="dialog-actions">
        <button id="dialog-cancel" class="btn">Cancel</button>
        <button id="dialog-ok" class="btn primary">OK</button>
      </div>
    </div>
  </div>

  <!-- Layout chooser overlay -->
  <div id="layout-overlay">
    <div id="layout-card">
      <h2 id="layout-title">Layouts</h2>
      <p id="layout-message">Choose how to arrange the current graph.</p>

      <div id="layout-list">
        <button class="btn" data-layout="tree-down">Tree: top → bottom</button>
        <button class="btn" data-layout="tree-up">Tree: bottom → top</button>
        <button class="btn" data-layout="tree-right">Tree: left → right</button>
        <button class="btn" data-layout="tree-left">Tree: right → left</button>
      </div>

      <div class="layout-actions">
        <button id="layout-close" class="btn">Cancel</button>
      </div>
    </div>
  </div>




  <!-- Node description overlay -->
  <div id="desc-overlay">
    <div id="desc-card">
      <h2>Node description</h2>
      <div id="desc-node-label"></div>
      <textarea id="desc-text" placeholder="Describe this node…"></textarea>
      <div class="desc-actions">
        <button id="desc-cancel" class="btn">Cancel</button>
        <button id="desc-save" class="btn primary">Save</button>
      </div>
    </div>
  </div>

  <!-- Rename node overlay -->
  <div id="rename-overlay">
    <div id="rename-card">
      <h2>Rename node</h2>
      <input id="rename-input" placeholder="Node title" />
      <div class="desc-actions">
        <button id="rename-cancel" class="btn">Cancel</button>
        <button id="rename-save" class="btn primary">Save</button>
      </div>
    </div>
  </div>

  <!-- Config overlay -->
  <div id="config-overlay">
    <div id="config-card">
      <h2>Settings</h2>

      <div class="config-section">
        <h3>Storage</h3>
        <p id="config-db-size" class="config-note">IndexedDB usage: calculating…</p>
        <div class="config-row">
          <button id="config-db-refresh" class="btn">Recalculate size</button>
          <button id="config-db-clear" class="btn danger">Clear database</button>
        </div>
        <p class="config-note">Clearing removes all projects, states and history from this browser.</p>
      </div>

      <div class="config-section">
        <h3>Backup</h3>
        <div class="config-row">
          <button id="config-export" class="btn">Export data (JSON)</button>
        </div>
        <div class="config-row">
          <input id="config-import-file" type="file" accept="application/json">
        </div>
        <div class="config-row config-import-modes">
          <label><input type="radio" name="import-mode" value="replace" checked> Replace existing data</label>
          <label><input type="radio" name="import-mode" value="merge"> Merge / link to existing</label>
        </div>
        <div class="config-row">
          <button id="config-import-run" class="btn primary">Import from file</button>
        </div>
      </div>

      <div class="config-section">
        <h3>Appearance</h3>
        <div class="config-row">
          <button id="config-theme-toggle" class="btn">Theme: Dark</button>
        </div>
      </div>

      <div class="desc-actions">
        <button id="config-close" class="btn">Close</button>
      </div>
    </div>
  </div>


  <div id="canvas-wrapper">


    <div id="zoom-controls">
      <button id="zoom-out"   class="btn" title="Zoom out">−</button>
      <span id="zoom-label">100%</span>
      <button id="zoom-in"    class="btn" title="Zoom in">+</button>
      <button id="zoom-reset" class="btn" title="Reset zoom to 100%">100%</button>
      <button id="zoom-fit"   class="btn" title="Fit all nodes">⤢</button>
    </div>

    <svg id="canvas">
      <g id="links-layer"></g>
      <line id="temp-link" x1="0" y1="0" x2="0" y2="0"></line>

      <!-- little marker when hovering / snapping over a line -->
      <circle id="hover-dot"
      r="4"
      fill="#ffffff"
      stroke="#000000"
      stroke-width="1"
      style="display:none; pointer-events:none;"></circle>

      <!-- debug circle showing the midpoint of a multi-touch gesture -->
      <circle id="pinch-center"
      r="12"
      fill="none"
      stroke="#22c55e"
      stroke-width="2"
      style="display:none; pointer-events:none;"></circle>


      <g id="nodes-layer"></g>
    </svg>


    <div id="menu">
      <button data-action="connect">Start connection</button>
      <button data-action="rename">Rename</button>
      <button data-action="description">Description</button> 
      <button data-action="duplicate">Clone</button>
      <hr>
      <button class="danger" data-action="delete">Delete</button>
    </div>

    <div id="topbar">


      <span class="label">Project:</span>
      <span id="proj-label" class="kbd">—</span>

      <span class="sep"></span>
      
      <button id="btn-switch" class="btn">Open</button>
      <button id="btn-new" class="btn">New</button>
      <button id="btn-dup" class="btn">Clone</button>
      <button id="btn-del" class="btn danger">Delete</button>
      <button id="btn-layouts" class="btn">Layouts</button>

      <button id="btn-clear-lines" class="btn">Clear Lines</button>
      <button id="btn-clear" class="btn danger">Clear</button>      

      <button id="btn-config" class="btn">Config</button>
      <button id="btn-help" class="btn" title="Show help">?</button>

    </div>

    <div id="palette"></div>
    <input id="palette-color-input" type="color" aria-label="Pick color" />

    <div id="status">Mode: create/open a project</div>

    <div id="project-gate" style="display:none;">
      <div id="project-card">
        <div class="project-card-header">
          <h2>Projects</h2>
          <button id="project-close" class="btn project-close-btn" aria-label="Close projects">×</button>
        </div>
        <div id="projects-list"></div>
        <div id="project-form">
          <input id="project-name" placeholder="New project name" />
          <button id="create-project" class="btn primary">Create</button>
          <button id="import-project" class="btn">Import</button>
          <input id="project-import-file" type="file" accept="application/json" style="display:none" />
        </div>
      </div>
    </div>


    <div id="gate-cover" class="disabled-cover" style="display:none;"></div>

    <!-- Mobile controls -->
    <button id="hamburger" aria-label="Menu"><span>☰</span></button>

    <div id="hamburger-menu" role="menu">
      <button data-mobile="hint">Hint</button>
      <button data-mobile="open">Open</button>
      <button data-mobile="new">New</button>
      <button data-mobile="dup">Clone</button>
      <button data-mobile="del">Delete</button>
      <button data-mobile="save">Save</button>

      <button data-mobile="export">Export project</button>
      <button data-mobile="import">Import project</button>

      <button data-mobile="clear-lines">Clear lines</button>
      <button data-mobile="clear-all">Clear all</button>
      <button data-mobile="layouts">Layouts…</button>

      <button data-mobile="config">Config</button>
    </div>



    <div id="mobile-undo-redo">
      <button id="btn-undo" class="btn" title="Undo">Undo</button>
      <button id="btn-redo" class="btn" title="Redo">Redo</button>
      <button id="btn-save" class="btn primary" title="Save">Save</button>
    </div>

    <div id="tool-rail">
      <button id="tool-lines"  class="tool" title="Lines mode"><span class="lbl">Lines</span></button>
      <button id="tool-edit"   class="tool" title="Edit mode"><span class="lbl">Edit</span></button>
      <button id="tool-break"  class="tool" title="Break lines"><span class="lbl">Break</span></button>
      <button id="tool-delete" class="tool" title="Delete mode"><span class="lbl">Delete</span></button>
    </div>


  </div>

  <script>

    (function(){

      // ----- Core refs -----
      const svg = document.getElementById("canvas");
      const nodesLayer = document.getElementById("nodes-layer");
      const linksLayer = document.getElementById("links-layer");
      const tempLink = document.getElementById("temp-link");
      const hoverDot = document.getElementById("hover-dot");

      const statusEl = document.getElementById("status");
      const menu = document.getElementById("menu");
      const wrapper = document.getElementById("canvas-wrapper");
      const sidebar = document.getElementById("sidebar");
      const btnHelp = document.getElementById("btn-help");

      const gate = document.getElementById("project-gate");
      const listEl = document.getElementById("projects-list");
      const projNameInput = document.getElementById("project-name");
      const createBtn = document.getElementById("create-project");
      const projectImportBtn  = document.getElementById("import-project");
      const projectImportFile = document.getElementById("project-import-file");
      const projLabel = document.getElementById("proj-label");
      const projectClose = document.getElementById("project-close");

      const btnSwitch = document.getElementById("btn-switch");
      const btnNew    = document.getElementById("btn-new");
      const btnDup    = document.getElementById("btn-dup");
      const btnDel    = document.getElementById("btn-del");
      const btnUndo   = document.getElementById("btn-undo");
      const btnRedo   = document.getElementById("btn-redo");
      const btnSave   = document.getElementById("btn-save");
      const btnClearLines = document.getElementById("btn-clear-lines");
      const btnClear      = document.getElementById("btn-clear");


      const gateCover = document.getElementById("gate-cover");

      const zoomInBtn  = document.getElementById("zoom-in");
      const zoomOutBtn = document.getElementById("zoom-out");
      const zoomLabel  = document.getElementById("zoom-label");
      const zoomResetBtn = document.getElementById("zoom-reset");
      const zoomFitBtn   = document.getElementById("zoom-fit");


      const paletteEl = document.getElementById("palette");
      const colorInput = document.getElementById("palette-color-input");

      /* Description overlay refs */
      const descOverlay    = document.getElementById("desc-overlay");
      const descCard       = document.getElementById("desc-card");
      const descNodeLabel  = document.getElementById("desc-node-label");
      const descText       = document.getElementById("desc-text");
      const descCancelBtn  = document.getElementById("desc-cancel");
      const descSaveBtn    = document.getElementById("desc-save");

      /* Rename overlay refs */
      const renameOverlay  = document.getElementById("rename-overlay");
      const renameInput    = document.getElementById("rename-input");
      const renameCancel   = document.getElementById("rename-cancel");
      const renameSave     = document.getElementById("rename-save");

      /* Mobile refs */
      const hamburger = document.getElementById("hamburger");
      const hambMenu  = document.getElementById("hamburger-menu");

      const toolLines = document.getElementById("tool-lines");
      const toolEdit  = document.getElementById("tool-edit");
      const toolBreak  = document.getElementById("tool-break");
      const toolDelete= document.getElementById("tool-delete");


      const btnConfig = document.getElementById("btn-config");

      // Config overlay refs
      const configOverlay     = document.getElementById("config-overlay");
      const configCloseBtn    = document.getElementById("config-close");
      const configDbSize      = document.getElementById("config-db-size");
      const configDbRefresh   = document.getElementById("config-db-refresh");
      const configDbClear     = document.getElementById("config-db-clear");
      const configExportBtn   = document.getElementById("config-export");
      const configImportFile  = document.getElementById("config-import-file");
      const configImportRun   = document.getElementById("config-import-run");
      const configThemeToggle = document.getElementById("config-theme-toggle");

      const THEME_KEY = "nodeCanvasTheme";


      /* Dialog overlay refs */
      const dialogOverlay  = document.getElementById("dialog-overlay");
      const dialogTitle    = document.getElementById("dialog-title");
      const dialogMessage  = document.getElementById("dialog-message");
      const dialogInput    = document.getElementById("dialog-input");
      const dialogCancel   = document.getElementById("dialog-cancel");
      const dialogOk       = document.getElementById("dialog-ok");      


      /* Layout overlay refs */
      const layoutOverlay  = document.getElementById("layout-overlay");
      const layoutClose    = document.getElementById("layout-close");
      const layoutList     = document.getElementById("layout-list");

      const btnLayouts     = document.getElementById("btn-layouts");



      let projectListItems = [];



      // ----- Graph state -----
      let nodes = [], links = [], nextId = 1;
      let hasUnsavedChanges = false;

      // Palette state
      let palette = { colors: ['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected: 0 };

      let dragNode = null;
      let dragOffset = {x:0,y:0};
      let linkingFrom = null;
      let linkActive = false;       // follows pointer while linking
      let menuNode = null;
      let lastHoverNode = null;
      let dragCandidate = null;

      // Node state
      let selectedNodeId = null;
      let descNode = null;      // node currently being edited in description modal
      let renameNodeRef = null; // node currently being renamed

      // Pointer UX
      const LONG_PRESS_MS = 500;
      const DRAG_MENU_CANCEL_PX = 6;
      let pressTimer = null;
      let downX=0, downY=0;

      // Background tap → create node (but not during pan)
      let bgTapCandidate = null;
      const BG_TAP_CANCEL_PX = 6;      

      // Projects/History (IndexedDB)
      let db = null;
      const DB_NAME = "node-editor";
      const DB_VER = 1;
      let currentProject = null;
      let undoStack = [];
      let redoStack = [];

      /* Mobile tool modes */
      let linesMode = false;   // tap sequence of nodes to chain-connect
      let editMode  = false;   // tap opens node context menu
      let deleteMode= false;   // tap deletes node
      let breakMode  = false; 
      let chainFrom = null;    // last node tapped in linesMode
      let tapMoved  = false;   // tracks movement to distinguish drag vs tap
      let touchPanActive = false;

      // ----- Canvas view (endless pan via viewBox) -----
      const viewBox = { x: 0, y: 0, w: 0, h: 0 };
      let baseViewBox = { w: 0, h: 0 };   // initial viewBox size for zoom=1

      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      let viewBoxStart = { x: 0, y: 0 };
      let spacePressed = false;

      /* Zoom state */
      let zoom = 1;
      const MIN_ZOOM = 0.01;
      const MAX_ZOOM = 5;
      const ZOOM_STEP = 1.2;      

      function updateZoomLabel(){
        if (!zoomLabel) return;
        zoomLabel.textContent = `${(zoom * 100).toFixed(0)}%`;
      }

      function initViewBox() {
        const rect = svg.getBoundingClientRect();
        viewBox.w = rect.width || 1024;
        viewBox.h = rect.height || 768;

        baseViewBox.w = viewBox.w;
        baseViewBox.h = viewBox.h;

        zoom = 1;
        svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      }

      function updateViewBox() {
        svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      }


      function resetZoomTo100(){
        const rect = svg.getBoundingClientRect();
        // Fall back to current viewport if baseViewBox is not set
        viewBox.w = baseViewBox.w || rect.width || 1024;
        viewBox.h = baseViewBox.h || rect.height || 768;
        viewBox.x = 0;
        viewBox.y = 0;

        zoom = 1;
        updateViewBox();
        updateZoomLabel();
        setStatus("Zoom: 100%");
      }

      function screenToSvg(clientX, clientY){
        const pt = svg.createSVGPoint();
        pt.x = clientX;
        pt.y = clientY;
        return pt.matrixTransform(svg.getScreenCTM().inverse());
      }



      function getNodesBounds(){
        if (!nodes.length) return null;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        nodes.forEach(n => {
          if (n.x < minX) minX = n.x;
          if (n.x > maxX) maxX = n.x;
          if (n.y < minY) minY = n.y;
          if (n.y > maxY) maxY = n.y;
        });
        return { minX, maxX, minY, maxY };
      }

      function zoomToFit(){
        const rect = svg.getBoundingClientRect();
        const bounds = getNodesBounds();

        // If nothing on canvas: just reset
        if (!bounds) {
          resetZoomTo100();
          return;
        }

        const padding = 80;

        let contentW = (bounds.maxX - bounds.minX) || 1;
        let contentH = (bounds.maxY - bounds.minY) || 1;
        contentW += padding * 2;
        contentH += padding * 2;

        const viewportRatio = rect.width / rect.height;
        const contentRatio  = contentW / contentH;

        let boxW, boxH;
        if (contentRatio > viewportRatio) {
          // limited by width
          boxW = contentW;
          boxH = contentW / viewportRatio;
        } else {
          // limited by height
          boxH = contentH;
          boxW = contentH * viewportRatio;
        }

        const cx = (bounds.minX + bounds.maxX) / 2;
        const cy = (bounds.minY + bounds.maxY) / 2;

        viewBox.w = boxW;
        viewBox.h = boxH;
        viewBox.x = cx - boxW / 2;
        viewBox.y = cy - boxH / 2;

        updateViewBox();

        // Recompute zoom value relative to the base viewBox width
        const baseW = baseViewBox.w || rect.width || boxW;
        zoom = baseW / viewBox.w;
        updateZoomLabel();
        setStatus("Zoom: fit to map");
      }



      function applyZoomFactor(factor, clientX, clientY) {
        // Clamp target zoom
        const prevZoom = zoom;
        let nextZoom = zoom * factor;
        if (nextZoom < MIN_ZOOM) nextZoom = MIN_ZOOM;
        if (nextZoom > MAX_ZOOM) nextZoom = MAX_ZOOM;

        const allowedFactor = nextZoom / prevZoom;
        if (allowedFactor === 1) return;

        const rect = svg.getBoundingClientRect();

        // If no focus point given, zoom toward center of viewport
        const cx = clientX ?? (rect.left + rect.width / 2);
        const cy = clientY ?? (rect.top + rect.height / 2);

        // Convert screen point → SVG coords
        const pt = svg.createSVGPoint();
        pt.x = cx;
        pt.y = cy;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

        // Scale viewBox
        viewBox.w /= allowedFactor;
        viewBox.h /= allowedFactor;

        // Adjust origin so the focus SVG point stays under the same screen point
        const nx = svgP.x - ((cx - rect.left) / rect.width) * viewBox.w;
        const ny = svgP.y - ((cy - rect.top) / rect.height) * viewBox.h;
        viewBox.x = nx;
        viewBox.y = ny;

        zoom = nextZoom;
        updateViewBox();
        updateZoomLabel();
        setStatus(`Zoom: ${(zoom * 100).toFixed(0)}%`);

        updateViewBox();

        setStatus(`Zoom: ${(zoom * 100).toFixed(0)}%`);
      }



      function startPan(e) {
        isPanning = true;
        panStart.x = e.clientX;
        panStart.y = e.clientY;
        viewBoxStart.x = viewBox.x;
        viewBoxStart.y = viewBox.y;
        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onPanMove);
        svg.addEventListener("pointerup", endPan, { once: true });
        setStatus("Panning (Space + drag)");
      }

      function onPanMove(e) {
        if (!isPanning) return;
        const rect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / rect.width;
        const scaleY = viewBox.h / rect.height;
        const dx = (e.clientX - panStart.x) * scaleX;
        const dy = (e.clientY - panStart.y) * scaleY;
        viewBox.x = viewBoxStart.x - dx;
        viewBox.y = viewBoxStart.y - dy;
        updateViewBox();
      }

      function endPan(e) {
        isPanning = false;
        if (e.pointerId != null) {
          try { svg.releasePointerCapture(e.pointerId); } catch(_) {}
        }
        svg.removeEventListener("pointermove", onPanMove);
      }




      // ----- Utils -----


      function confirmDialog(message, title){
        return openDialog({
          title: title || "Confirm",
          message,
          showInput: false,
          okText: "Yes",
          cancelText: "No"
        });
      }

      function promptDialog(message, defaultValue, title){
        return openDialog({
          title: title || "Input",
          message,
          showInput: true,
          defaultValue,
          okText: "OK",
          cancelText: "Cancel"
        });
      }







      async function duplicateCurrentProject(newName){
        try {
          await confirmSaveIfDirty();
          const dup = await duplicateProject(currentProject.id, newName);
          await refreshProjectList();
          await openProject(dup);
          setStatus(`Cloned as "${dup.name}"`);
        } catch (err) {
          console.error("Clone from hamburger failed", err);
          setStatus("Clone failed (name exists?)");
        }
      }


      function isTextEditingTarget(e){
        const el = e.target;
        if (!el) return false;
        const tag = el.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA") return true;
        if (el.isContentEditable) return true;
        return false;
      }


      // distance + projection of a point to a segment
      function pointSegmentInfo(px, py, x1, y1, x2, y2){
        const dx = x2 - x1;
        const dy = y2 - y1;
        if (dx === 0 && dy === 0){
          const d = dist(px, py, x1, y1);
          return { dist: d, t: 0, x: x1, y: y1 };
        }
        const tRaw = ((px - x1) * dx + (py - y1) * dy) / (dx*dx + dy*dy);
        const t = Math.max(0, Math.min(1, tRaw));      // clamp to segment
        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        const d = dist(px, py, projX, projY);
        return { dist: d, t, x: projX, y: projY };
      }

      // find the best link under (px,py)
      function findNearestLinkPoint(px, py, opts={}){
        const maxDist     = opts.maxDist ?? 24;
        const ignoreNodeId= opts.ignoreNodeId ?? null;
        let best = null;

        links.forEach(link => {
          const from = nodes.find(n => n.id === link.from);
          const to   = nodes.find(n => n.id === link.to);
          if (!from || !to) return;

          // optional: ignore links attached to a specific node
          if (ignoreNodeId && (from.id === ignoreNodeId || to.id === ignoreNodeId)) return;

          const info = pointSegmentInfo(px, py, from.x, from.y, to.x, to.y);

          // ignore very near endpoints (t ~ 0 or 1)
          if (info.dist <= maxDist && info.t > 0.08 && info.t < 0.92){
            if (!best || info.dist < best.info.dist){
              best = { link, from, to, info };
            }
          }
        });

        return best;
      }

      // create a new node on a link (click-on-line)
      function insertNodeOnNearestLink(px, py){
        const best = findNearestLinkPoint(px, py, { maxDist: 24 });
        if (!best) return false;

        // create node snapped onto the line
        const newId = nextId;
        addNodeWrapped(best.info.x, best.info.y);
        const newNode = nodes.find(n => n.id === newId);
        if (!newNode) return false;

        const originalColor =
        (best.link.style && best.link.style.color) || selectedColor();

        // remove original link
        links = links.filter(l => l !== best.link);

        // add two new links with same color
        links.push(
          { from: best.from.id, to: newNode.id, style: { color: originalColor } },
          { from: newNode.id,   to: best.to.id, style: { color: originalColor } }
          );
        renderLinks();

        pushAction({
          type: "SPLIT_LINK",
          at: Date.now(),
          from: best.from.id,
          to:   best.to.id,
          via:  newNode.id,
          color: originalColor
        });

        setStatus(`Inserted node between ${best.from.label} and ${best.to.label}`);
        return true;
      }

      function deleteNearestLinkAt(px, py){
        const best = findNearestLinkPoint(px, py, { maxDist: 24 });
        if (!best) return false;

        links = links.filter(l => l !== best.link);
        renderLinks();

        pushAction({
          type: "DELETE_LINK",
          at: Date.now(),
          from: best.link.from,
          to:   best.link.to
        });

        hideHoverDot();
        setStatus(`Removed link ${best.from.label} → ${best.to.label}`);
        return true;
      }



      // reuse splitting logic when dropping an existing node onto a link
      function splitExistingLinkWithNode(node, best){
        const original = best.link;
        const originalColor =
        (original.style && original.style.color) || selectedColor();

        // remove the original link
        links = links.filter(l => l !== original);

        // add two new links that pass through this node
        links.push(
          { from: best.from.id, to: node.id, style: { color: originalColor } },
          { from: node.id,      to: best.to.id, style: { color: originalColor } }
          );
        renderLinks();

        pushAction({
          type: "SPLIT_LINK_WITH_EXISTING_NODE",
          at: Date.now(),
          via:  node.id,
          from: best.from.id,
          to:   best.to.id,
          color: originalColor
        });

        setStatus(`Inserted ${node.label} into link ${best.from.label} → ${best.to.label}`);
      }


      // ----- Graph layout engine (tree in 4 directions) -----

      function showLayoutOverlay(){
        if (!nodes.length){
          setStatus("No nodes to layout");
          return;
        }
        layoutOverlay.style.display = "flex";
      }

      function hideLayoutOverlay(){
        layoutOverlay.style.display = "none";
      }

      if (btnLayouts){
        btnLayouts.addEventListener("click", () => {
          showLayoutOverlay();
        });
      }

      if (layoutClose){
        layoutClose.addEventListener("click", () => {
          hideLayoutOverlay();
        });
      }

      if (layoutOverlay){
        layoutOverlay.addEventListener("pointerdown", (e) => {
          if (e.target === layoutOverlay){
            hideLayoutOverlay();
          }
        });
      }

      if (layoutList){
        layoutList.addEventListener("click", (e) => {
          const btn = e.target.closest("button[data-layout]");
          if (!btn) return;
          const kind = btn.getAttribute("data-layout");
          applyNamedLayout(kind);
          hideLayoutOverlay();
        });
      }





      function autoGraphLayout(opts = {}) {
        if (!nodes.length) {
          setStatus("No nodes to layout");
          return;
        }

  const direction = opts.direction || "down"; // "down" | "up" | "right" | "left"
  const rootLabel = (opts.rootLabel || "").trim().toLowerCase();

  const nodeById = new Map(nodes.map(n => [n.id, n]));

  // ----- Build directed children + parent counts from links -----
  const children = new Map();   // id -> [childId, ...]
  const parentCount = new Map(); // id -> number of incoming edges

  links.forEach(l => {
    if (!children.has(l.from)) children.set(l.from, []);
    children.get(l.from).push(l.to);
    parentCount.set(l.to, (parentCount.get(l.to) || 0) + 1);
  });

  // ----- Pick root ------------------------------------------------
  let root = null;

  // 1) Explicit label
  if (rootLabel) {
    const exact = nodes.find(
      n => (n.label || "").toLowerCase() === rootLabel
      );
    const prefix = nodes.find(
      n => (n.label || "").toLowerCase().startsWith(rootLabel)
      );
    root = exact || prefix || null;
  }

  // 2) Currently selected node (user intent)
  if (!root && selectedNodeId != null) {
    root = nodeById.get(selectedNodeId) || null;
  }

  // 3) Node with no parents, otherwise fewest parents, otherwise first
  if (!root) {
    let candidate = null;
    let bestParents = Infinity;
    nodes.forEach(n => {
      const p = parentCount.get(n.id) || 0;
      if (p === 0 && candidate === null) {
        candidate = n;
        bestParents = 0;
      } else if (candidate === null && p < bestParents) {
        candidate = n;
        bestParents = p;
      }
    });
    root = candidate || nodes[0];
  }

  if (!root) {
    setStatus("No root for layout");
    return;
  }

  // ----- Build a cycle-free layout tree using BFS -----------------
  const depth = new Map();         // id -> layer (0 = root)
  const treeChildren = new Map();  // id -> [childId, ...] only tree edges
  const visited = new Set();

  function bfsFrom(startId, baseDepth) {
    if (visited.has(startId)) return;

    const q = [];
    visited.add(startId);
    depth.set(startId, baseDepth);
    q.push(startId);

    while (q.length) {
      const id = q.shift();
      const d = depth.get(id) || baseDepth;
      const kids = children.get(id) || [];

      kids.forEach(childId => {
        if (visited.has(childId)) return; // already has a parent in the tree

        visited.add(childId);
        depth.set(childId, d + 1);

        if (!treeChildren.has(id)) treeChildren.set(id, []);
        treeChildren.get(id).push(childId);

        q.push(childId);
      });
    }
  }

  // Main component from chosen root
  bfsFrom(root.id, 0);

  // Any disconnected components → own little trees starting at depth 0
  nodes.forEach(n => {
    if (!visited.has(n.id)) {
      bfsFrom(n.id, 0);
    }
  });

  // Max depth for "up"/"left" layouts
  let maxDepth = 0;
  depth.forEach(d => { if (d > maxDepth) maxDepth = d; });

  // ----- Horizontal ordering: centre parents over children --------
  const posIndex = new Map(); // id -> float "column index"
  let cursor = 0;

  function assignIndex(id) {
    if (posIndex.has(id)) return;

    const kids = treeChildren.get(id) || [];
    if (!kids.length) {
      // Leaf → take next free column
      posIndex.set(id, cursor++);
      return;
    }

    // First layout all children
    kids.forEach(assignIndex);

    // Parent sits at average of children
    const xs = kids.map(k => posIndex.get(k));
    const avg = xs.reduce((a, b) => a + b, 0) / xs.length;
    posIndex.set(id, avg);
  }

  // Layout main root first
  assignIndex(root.id);

  // Then any other roots / components
  nodes.forEach(n => {
    if (!posIndex.has(n.id)) assignIndex(n.id);
  });

  const indices = Array.from(posIndex.values());
  const minIdx = Math.min.apply(null, indices);

  const hGap = opts.hSpacing || 140;
  const vGap = opts.vSpacing || 90;
  const margin = 80;

  // ----- Assign final coordinates ---------------------------------
  nodes.forEach(n => {
    const d = depth.get(n.id) || 0;
    const line = (posIndex.get(n.id) - minIdx) || 0;

    let x, y;
    switch (direction) {
    case "up":
      x = margin + line * hGap;
      y = margin + (maxDepth - d) * vGap;
      break;
    case "right":
      x = margin + d * vGap;
      y = margin + line * hGap;
      break;
    case "left":
      x = margin + (maxDepth - d) * vGap;
      y = margin + line * hGap;
      break;
    case "down":
    default:
      x = margin + line * hGap;
      y = margin + d * vGap;
      break;
    }

    n.x = x;
    n.y = y;
  });

  renderAll();
  pushAction({
    type: "APPLY_LAYOUT",
    at: Date.now(),
    direction,
    rootLabel: root.label
  });

  zoomToFit();
  setStatus(`Layout "${direction}" from root "${root.label}"`);
}












function applyNamedLayout(kind){
  if (!nodes.length) {
    setStatus("No nodes to layout");
    return;
  }
  switch (kind) {
  case "tree-up":
    autoGraphLayout({ direction: "up" });
    break;
  case "tree-right":
    autoGraphLayout({ direction: "right" });
    break;
  case "tree-left":
    autoGraphLayout({ direction: "left" });
    break;
  case "tree-down":
  default:
    autoGraphLayout({ direction: "down" });
    break;
  }
}



function setStatus(text){ statusEl.textContent = text; }


let dialogResolve = null;

function closeDialog(){
  dialogOverlay.style.display = "none";
  dialogResolve = null;
}

function openDialog(opts){
  dialogTitle.textContent = opts.title || "";
  dialogMessage.textContent = opts.message || "";
  if (opts.showInput){
    dialogInput.style.display = "block";
    dialogInput.value = opts.defaultValue || "";
    setTimeout(()=>{
      dialogInput.focus();
      dialogInput.select();
    }, 0);
  } else {
    dialogInput.style.display = "none";
    dialogInput.value = "";
  }
  dialogOk.textContent = opts.okText || "OK";
  dialogCancel.textContent = opts.cancelText || "Cancel";
  dialogOverlay.style.display = "flex";

  return new Promise(resolve=>{
    dialogResolve = resolve;
  });
}

function confirmDialog(message, title){
  return openDialog({
    title: title || "Confirm",
    message,
    showInput: false
  });
}

function promptDialog(message, defaultValue, title){
  return openDialog({
    title: title || "Input",
    message,
    showInput: true,
    defaultValue
  });
}

if (dialogCancel){
  dialogCancel.addEventListener("click", ()=>{
    if (dialogResolve) dialogResolve({ ok:false, value:null });
    closeDialog();
  });
}

if (dialogOk){
  dialogOk.addEventListener("click", ()=>{
    if (!dialogResolve){
      closeDialog();
      return;
    }
    const value = dialogInput.style.display === "none" ? null : dialogInput.value;
    dialogResolve({ ok:true, value });
    closeDialog();
  });
}

if (dialogOverlay){
  dialogOverlay.addEventListener("pointerdown", (e)=>{
    if (e.target === dialogOverlay){
      if (dialogResolve) dialogResolve({ ok:false, value:null });
      closeDialog();
    }
  });
}

if (dialogInput){
  dialogInput.addEventListener("keydown", (e)=>{
    if (e.key === "Enter"){
      e.preventDefault();
      dialogOk.click();
    } else if (e.key === "Escape"){
      e.preventDefault();
      dialogCancel.click();
    }
  });
}












function showHoverDotAt(x, y){
  if (!hoverDot) return;
  hoverDot.setAttribute("cx", x);
  hoverDot.setAttribute("cy", y);
  hoverDot.style.display = "block";
}

function hideHoverDot(){
  if (!hoverDot) return;
  hoverDot.style.display = "none";
}




function svgPoint(evt){
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX; pt.y = evt.clientY;
  return pt.matrixTransform(svg.getScreenCTM().inverse());
}
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }
const selectedColor = ()=> palette.colors[palette.selected] || '#3b82f6';
const normHex = (v)=>{
  let s = String(v||'').trim();
  if (!s) return '#3b82f6';
  if (s[0] !== '#') s = '#'+s;
  if (/^#([0-9a-f]{3})$/i.test(s)) s = '#'+s.slice(1).split('').map(x=>x+x).join('');
  if (!/^#([0-9a-f]{6})$/i.test(s)) return '#3b82f6';
  return s.toLowerCase();
};

function setNodeDescription(node, text){
  const old = node.description || "";
  node.description = text;
  pushAction({ type:"SET_DESCRIPTION", at:Date.now(), id:node.id, from:old, to:text });
}

function openDescriptionModal(node){
  descNode = node;
  descNodeLabel.textContent = `Node: ${node.label}`;
  descText.value = node.description || "";
  descOverlay.style.display = "flex";
}

function closeDescriptionModal(){
  descOverlay.style.display = "none";
  descNode = null;
}

function openRenameModal(node){
  renameNodeRef = node;
  renameInput.value = node.label || "";
  renameOverlay.style.display = "flex";
  setTimeout(() => {
    renameInput.focus();
    renameInput.select();
  }, 10);
}

function closeRenameModal(){
  renameOverlay.style.display = "none";
  renameNodeRef = null;
}

      // ----- IndexedDB -----
function openDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = (e)=>{
      const db = e.target.result;
      if (!db.objectStoreNames.contains("projects")) {
        const s = db.createObjectStore("projects", { keyPath: "id", autoIncrement: true });
        s.createIndex("by_name","name",{ unique: true });
      }
      if (!db.objectStoreNames.contains("states")) {
        const s2 = db.createObjectStore("states", { keyPath: ["projectId","rev"] });
        s2.createIndex("by_project","projectId");
      }
      if (!db.objectStoreNames.contains("history")) {
        const s3 = db.createObjectStore("history", { keyPath: ["projectId","seq"] });
        s3.createIndex("by_project","projectId");
      }
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror   = ()=> reject(req.error);
  });
}
function tx(storeNames, mode="readonly"){ return db.transaction(storeNames, mode); }

      // ----- Projects API -----
async function listProjects(){
  const out = [];
  await new Promise((res,rej)=>{
    const t = tx(["projects"]);
    const req = t.objectStore("projects").openCursor();
    req.onsuccess = (e)=>{ const cur=e.target.result; if(cur){ out.push(cur.value); cur.continue(); } else res(); };
    req.onerror  = ()=>rej(req.error);
  });
  return out.sort((a,b)=> (b.updatedAt||b.createdAt||0) - (a.updatedAt||a.createdAt||0));
}
async function createProject(name){
  const now = Date.now();
  const meta = { name, createdAt: now, updatedAt: now, pointer: 0, palette };
  const t = tx(["projects"],"readwrite");
  const req = t.objectStore("projects").add(meta);
  const id = await new Promise((res,rej)=>{ req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); });
  await saveStateSnapshot(id, 0, { nodes:[], links:[], nextId:1 });
  await saveHistoryRecord(id, 1, { type:"INIT", at: now });
  return { id, ...meta };
}



async function duplicateProject(sourceId, newName){
  const now = Date.now();

        // 1) Read original project meta in its own transaction
  const origin = await new Promise((res, rej) => {
          const t = tx(["projects"]); // readonly is fine
          const r = t.objectStore("projects").get(sourceId);
          r.onsuccess = () => res(r.result);
          r.onerror   = () => rej(r.error);
        });

  const meta = {
    name: newName,
    createdAt: now,
    updatedAt: now,
    pointer: 0,
    palette: origin?.palette || palette
  };

        // 2) Create new project record in a fresh readwrite transaction
  const newId = await new Promise((res, rej) => {
    const t = tx(["projects"], "readwrite");
    const addReq = t.objectStore("projects").add(meta);
    addReq.onsuccess = () => res(addReq.result);
    addReq.onerror   = () => rej(addReq.error);
  });

        // 3) Copy all states
  let maxRev = 0;
  await new Promise((res, rej) => {
    const t2  = tx(["states"], "readwrite");
    const idx = t2.objectStore("states").index("by_project")
    .openCursor(IDBKeyRange.only(sourceId));

    idx.onsuccess = (e) => {
      const c = e.target.result;
      if (c) {
        const { rev, state } = c.value;
        maxRev = Math.max(maxRev, rev);
        t2.objectStore("states").put({
          projectId: newId,
          rev,
          state: JSON.parse(JSON.stringify(state))
        });
        c.continue();
      } else {
        res();
      }
    };
    idx.onerror = () => rej(idx.error);
  });

        // 4) Copy history
  await new Promise((res, rej) => {
    const t3  = tx(["history"], "readwrite");
    const idx = t3.objectStore("history").index("by_project")
    .openCursor(IDBKeyRange.only(sourceId));

    idx.onsuccess = (e) => {
      const c = e.target.result;
      if (c) {
        const { seq, action } = c.value;
        t3.objectStore("history").put({
          projectId: newId,
          seq,
          action: JSON.parse(JSON.stringify(action))
        });
        c.continue();
      } else {
        res();
      }
    };
    idx.onerror = () => rej(idx.error);
  });

        // 5) Finalize new project meta with correct pointer
  const finalMeta = {
    id: newId,
    name: newName,
    createdAt: now,
    updatedAt: now,
    pointer: maxRev,
    palette: origin?.palette || palette
  };

  await new Promise((res, rej) => {
    const t4    = tx(["projects"], "readwrite");
    const putReq = t4.objectStore("projects").put(finalMeta);
    putReq.onsuccess = () => res();
    putReq.onerror   = () => rej(putReq.error);
  });

  return finalMeta;
}



async function updateProjectMeta(patch){
  if (!currentProject) return;
  const now = Date.now();
  const t = tx(["projects"],"readwrite");
  const obj = { ...currentProject, ...patch, updatedAt: now };
  await new Promise((res,rej)=>{ const r=t.objectStore("projects").put(obj); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
  currentProject = obj;
  projLabel.textContent = currentProject.name;
}

      // ----- Snapshots / History -----
async function saveStateSnapshot(projectId, rev, state){
  const t = tx(["states"],"readwrite");
  await new Promise((res,rej)=>{ const r=t.objectStore("states").put({projectId,rev,state}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
}
async function loadLatestState(projectId){
  let maxRev=-1, latest=null;
  await new Promise((res,rej)=>{
    const t = tx(["states"]);
    const idx = t.objectStore("states").index("by_project");
    const r = idx.openCursor(IDBKeyRange.only(projectId));
    r.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {rev,state}=c.value; if(rev>maxRev){maxRev=rev; latest={rev,state};} c.continue(); } else res(); };
    r.onerror=()=>rej(r.error);
  });
  return latest || { rev:0, state:{ nodes:[], links:[], nextId:1 } };
}
async function saveHistoryRecord(projectId, seq, action){
  const t = tx(["history"],"readwrite");
  await new Promise((res,rej)=>{ const r=t.objectStore("history").put({projectId,seq,action}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
}
async function loadHistory(projectId){
  const items=[];
  await new Promise((res,rej)=>{
    const t = tx(["history"]);
    const idx = t.objectStore("history").index("by_project");
    const r = idx.openCursor(IDBKeyRange.only(projectId));
    r.onsuccess=(e)=>{ const c=e.target.result; if(c){ items.push(c.value); c.continue(); } else res(); };
    r.onerror=()=>rej(r.error);
  });
  items.sort((a,b)=>a.seq-b.seq);
  return items;
}

      // ----- History helpers -----
function snapshot(){ return { nodes: JSON.parse(JSON.stringify(nodes)), links: JSON.parse(JSON.stringify(links)), nextId }; }
function applyState(state){ nodes = JSON.parse(JSON.stringify(state.nodes||[])); links = JSON.parse(JSON.stringify(state.links||[])); nextId = state.nextId || 1; renderAll(); }


async function pushAction(action){
  if (!currentProject) return;
  undoStack.push(snapshot());
  redoStack.length = 0;
  hasUnsavedChanges = true;
  await appendHistory(action);
  updateProjectMeta({});
}

async function persistSnapshot(){
  if (!currentProject) return;
  const latest = await loadLatestState(currentProject.id);
  const newRev = latest.rev + 1;
  await saveStateSnapshot(currentProject.id, newRev, snapshot());
  await updateProjectMeta({ pointer: newRev, palette });
  hasUnsavedChanges = false;
  setStatus(`Saved rev ${newRev}`);
}

async function confirmSaveIfDirty(){
  if (!currentProject || !hasUnsavedChanges) return true;
  const msg = `You have unsaved changes in "${currentProject.name}". Save before continuing?`;
  const doSave = confirm(msg);
  if (doSave) {
    await persistSnapshot();
  }
  return true;
}



async function appendHistory(action){ const all = await loadHistory(currentProject.id); const nextSeq = (all.length? all[all.length-1].seq+1 : 1); await saveHistoryRecord(currentProject.id, nextSeq, action); }
async function rebuildStacksFromHistory(){ undoStack.length=0; redoStack.length=0; undoStack.push(snapshot()); }
async function doUndo(){ if (!currentProject || undoStack.length<=1) return; const cur=undoStack.pop(); redoStack.push(cur); const prev=undoStack[undoStack.length-1]; applyState(prev); setStatus("Undo"); await persistSnapshot(); }
async function doRedo(){ if (!currentProject || !redoStack.length) return; const nxt=redoStack.pop(); undoStack.push(nxt); applyState(nxt); setStatus("Redo"); await persistSnapshot(); }




      // ----- Graph CRUD -----
function makeDefaultStyle(){
  const c = selectedColor();
  return { shape:'pill', fill:c, stroke:c };
}

function addNodeWrapped(x,y){
  const node={id:nextId++,x,y,label:"N"+(nextId-1), style: makeDefaultStyle()};
  nodes.push(node);
  selectedNodeId = node.id;
  renderNodes();
  renderLinks();
  pushAction({type:"ADD_NODE",at:Date.now(),node});
}

function moveNodeWrapped(node){
  renderLinks();
  pushAction({type:"MOVE_NODE",at:Date.now(),id:node.id,x:node.x,y:node.y});
}

function deleteNodeWrapped(node){
  nodes=nodes.filter(n=>n.id!==node.id);
  links=links.filter(l=>l.from!==node.id&&l.to!==node.id);
  if (selectedNodeId === node.id) selectedNodeId = null;
  renderAll();
  pushAction({type:"DELETE_NODE",at:Date.now(),id:node.id});
}

function duplicateNodeWrapped(node, keepLabel=false){
  const newLabel = keepLabel ? (node.label ? node.label + "1" : "N"+nextId) : ("N"+nextId);
  const n2={ id:nextId++, x:node.x+28, y:node.y+28, label:newLabel, style: JSON.parse(JSON.stringify(node.style||makeDefaultStyle())) };
  nodes.push(n2);
  renderAll();
  pushAction({type:"DUPLICATE_NODE",at:Date.now(),from:node.id,to:n2.id});
}

function connectNodesWrapped(aId,bId){
  links.push({from:aId,to:bId, style:{color:selectedColor()}});
  renderLinks();
  pushAction({type:"CONNECT",at:Date.now(),from:aId,to:bId,color:selectedColor()});
}

function renameNodeWrapped(node,newLabel){
  const old=node.label;
  node.label=newLabel;
  updateNodeGraphics(node);
  pushAction({type:"RENAME_NODE",at:Date.now(),id:node.id,from:old,to:newLabel});
}

function restyleNodeWrapped(node, patch){
  node.style = { ...(node.style||makeDefaultStyle()), ...patch };
  updateNodeGraphics(node);
  pushAction({type:"STYLE_NODE", at:Date.now(), id:node.id, patch});
}

      // ----- Rendering -----
function renderNodes() {
  nodesLayer.innerHTML = "";
  nodes.forEach(node => {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.classList.add("node");
    g.dataset.id = String(node.id);

    const style = node.style || makeDefaultStyle();
    const isSelected = node.id === selectedNodeId;

    let shapeEl;
    if (style.shape === 'pill' || !style.shape) {
      const label = node.label || "";
      const baseWidth = 72;
      const dynWidth  = label.length * 9 + 24;
      const width     = Math.max(baseWidth, dynWidth);
      const height    = 32;

      shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      shapeEl.setAttribute("x", node.x - width / 2);
      shapeEl.setAttribute("y", node.y - height / 2);
      shapeEl.setAttribute("width",  width);
      shapeEl.setAttribute("height", height);
      shapeEl.setAttribute("rx", height / 2);
    } else if (style.shape === 'rect') {
      shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      shapeEl.setAttribute("x", node.x - 18);
      shapeEl.setAttribute("y", node.y - 18);
      shapeEl.setAttribute("width", 36);
      shapeEl.setAttribute("height", 36);
      shapeEl.setAttribute("rx", 6);
    } else if (style.shape === 'triangle') {
      shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const p1 = `${node.x},${node.y-20}`;
      const p2 = `${node.x-18},${node.y+16}`;
      const p3 = `${node.x+18},${node.y+16}`;
      shapeEl.setAttribute("points", `${p1} ${p2} ${p3}`);
    } else {
      shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      shapeEl.setAttribute("cx", node.x);
      shapeEl.setAttribute("cy", node.y);
      shapeEl.setAttribute("r", 18);
    }

    shapeEl.setAttribute("fill", style.fill);
    shapeEl.setAttribute("stroke", isSelected ? "#ffffff" : style.stroke);
    shapeEl.setAttribute("stroke-width", isSelected ? "3" : "2");

    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", node.x);
    text.setAttribute("y", node.y + 4);
    text.setAttribute("text-anchor", "middle");
    text.textContent = node.label;

    g.appendChild(shapeEl);
    g.appendChild(text);
    nodesLayer.appendChild(g);

    g.addEventListener("pointerenter", ()=>{ lastHoverNode = node; });
    g.addEventListener("pointerleave", ()=>{ if (lastHoverNode && lastHoverNode.id===node.id) lastHoverNode=null; });

    g.addEventListener("pointerdown", (e)=>onNodePointerDown(e, node));
    g.addEventListener("contextmenu", (e)=>openMenu(e, node));
    g.addEventListener("pointerdown", (e)=>startPressTimer(e, node));
    g.addEventListener("pointerup", cancelPressTimer, { passive:true });
    g.addEventListener("pointerleave", cancelPressTimer, { passive:true });

          /* Mobile taps and two-finger menu */
    g.addEventListener("pointerdown", ()=>{ tapMoved=false; });
    g.addEventListener("pointermove", ()=>{ tapMoved=true; });
    g.addEventListener("pointerup", (e)=> handleNodePointerUp(e, node), { passive:true });
    g.addEventListener("touchstart", (e)=> maybeTwoFingerMenu(e, node), { passive:false });
    g.addEventListener("touchend", clearTwoFingerTimer, { passive:true });
    g.addEventListener("touchmove", clearTwoFingerTimer, { passive:true });
  });
  setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
}

function renderLinks() {
  linksLayer.innerHTML = "";
  links.forEach(link => {
    const from = nodes.find(n => n.id === link.from);
    const to   = nodes.find(n => n.id === link.to);
    if (!from || !to) return;

    const shadow = document.createElementNS("http://www.w3.org/2000/svg", "line");
    shadow.classList.add("link-shadow");
    shadow.setAttribute("x1", from.x); shadow.setAttribute("y1", from.y);
    shadow.setAttribute("x2", to.x);   shadow.setAttribute("y2", to.y);

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.classList.add("link");
    line.setAttribute("x1", from.x); line.setAttribute("y1", from.y);
    line.setAttribute("x2", to.x);   line.setAttribute("y2", to.y);
    if (link.style && link.style.color) line.setAttribute("stroke", link.style.color);

    linksLayer.appendChild(shadow);
    linksLayer.appendChild(line);
  });
  setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
}

function renderAll(){ renderNodes(); renderLinks(); }
function updateNodeGraphics(){ renderAll(); }

      // ----- Context menu -----
function openMenu(e, node){
  if (linkingFrom || dragNode) return;
  e.preventDefault();

  cancelPressTimer();
  dragCandidate = null;

  closeMenu();
  menuNode = node;
  const rect = wrapper.getBoundingClientRect();
  const x = Math.min(e.clientX - rect.left, rect.width - 220);
  const y = Math.min(e.clientY - rect.top,  rect.height - 180);
  menu.style.left = x + "px";
  menu.style.top  = y + "px";
  menu.style.display = "block";
}

function closeMenu(){ menu.style.display = "none"; menuNode = null; }

menu.addEventListener("click", (e)=>{
  const btn = e.target.closest("button");
  if (!btn || !menuNode) return;
  const action = btn.dataset.action;

  if (action === "connect") {
    const from = menuNode;
    closeMenu();
    startConnectionFrom(from, { immediateFollow: true });
    return;
  }

  if (action === "rename") {
    const node = menuNode;
    closeMenu();
    openRenameModal(node);
    return;
  }

  if (action === "description") {
    const node = menuNode;
    closeMenu();
    openDescriptionModal(node);
    return;
  }

  if (action === "duplicate") { duplicateNodeWrapped(menuNode, true); }
  if (action === "delete")    { deleteNodeWrapped(menuNode); }

  closeMenu();
});

wrapper.addEventListener("pointerdown", (e)=>{
  if (e.target === svg) closeMenu();
});

      // ----- Space key pan mode -----
window.addEventListener("keydown", (e) => {
        if (isTextEditingTarget(e)) return;  // do nothing while typing
        if (e.code === "Space" && !spacePressed) {
          spacePressed = true;
          svg.style.cursor = "grab";
          e.preventDefault();
        }
      });



window.addEventListener("keyup", (e) => {
  if (e.code === "Space") {
    spacePressed = false;
    if (!isPanning) {
      svg.style.cursor = "";
    }
  }
});

      // ----- Keyboard (desktop) -----
window.addEventListener("keydown", async (e)=>{
        if (isTextEditingTarget(e)) return;   // ignore shortcuts while typing

        const mod = e.ctrlKey || e.metaKey;
        const k = e.key.toLowerCase();

        const rawKey = e.key;

        // Zoom via +/- keys (no modifiers)
        if (!mod) {
          // Zoom in: + key (usually Shift + =)
          if (rawKey === '+' || (rawKey === '=' && e.shiftKey)) {
            e.preventDefault();
            applyZoomFactor(ZOOM_STEP);
            return;
          }
          // Zoom out: - / _ keys
          if (rawKey === '-' || rawKey === '_') {
            e.preventDefault();
            applyZoomFactor(1 / ZOOM_STEP);
            return;
          }
        }



        if (mod && k==="s"){ e.preventDefault(); await persistSnapshot(); return; }
        if (mod && k==="z"){ e.preventDefault(); await doUndo(); return; }
        if (mod && k==="y"){ e.preventDefault(); await doRedo(); return; }

        if (k === "escape") {
          if (gate.style.display === "flex") {
            gateOff();
            return;
          }
          if (configOverlay && configOverlay.style.display === "flex") {
            hideConfigOverlay();
            return;
          }
          if (renameOverlay.style.display === "flex") { closeRenameModal(); return; }
          if (descOverlay.style.display === "flex") { closeDescriptionModal(); return; }
          closeMenu();
          cancelLinking();
          return;
        }


        // Toggle Lines mode with "l"
        if (!mod && !e.shiftKey && k === "l") {
          e.preventDefault();
          toolLines.click();
          return;
        }

        // Toggle Edit mode with "e"
        if (!mod && !e.shiftKey && k === "e") {
          e.preventDefault();
          toolEdit.click();
          return;
        }

        // Toggle Break mode with "b"
        if (!mod && !e.shiftKey && k === "b") {
          e.preventDefault();
          toolBreak.click();
          return;
        }

        // Toggle Delete tool mode with "d"
        // (no Shift so Shift+D still works as duplicate)
        if (!mod && !e.shiftKey && k === "d") {
          e.preventDefault();
          toolDelete.click();
          return;
        }


        if (!currentProject) return;
        if (k==="n"){
          if (!linkingFrom && lastHoverNode){
            closeMenu();
            startConnectionFrom(lastHoverNode, { immediateFollow: true });
          }
        }
        if (k==="x"){ if (lastHoverNode){ deleteNodeWrapped(lastHoverNode); } }
        if (e.shiftKey && k==="d"){ if (lastHoverNode){ duplicateNodeWrapped(lastHoverNode, true); } }
      });

      // ----- Pointer-based drag/move -----

function cancelPressTimer(){
  if (pressTimer){ clearTimeout(pressTimer); pressTimer=null; }
}




function startPressTimer(e, node){
        // still block long-press menu while linking or in Delete mode
  if (linkingFrom || deleteMode) return;
  cancelPressTimer();
  downX = e.clientX; 
  downY = e.clientY;
  pressTimer = setTimeout(()=>{ openMenu(e, node); }, LONG_PRESS_MS);
}




function onNodePointerDown(e, node){
  if (!currentProject){ 
    gateOn(); 
    return; 
  }

        // Right-click → open menu immediately
  if (e.button === 2){
    openMenu(e, node);
    return;
  }
        // Ignore middle button
  if (e.button === 1) return;

        // Delete mode: immediate remove on primary click
  if (deleteMode && e.button === 0){
    e.preventDefault();
    e.stopPropagation();
    cancelPressTimer();
    deleteNodeWrapped(node);
    return;
  }

        // If currently linking and a node is pressed, finish the connection.
  if (linkingFrom){
    e.preventDefault();
    if (node.id !== linkingFrom.id) { 
      connectNodesWrapped(linkingFrom.id, node.id); 
    }
    cancelLinking();
    return;
  }

        // Normal drag path (allowed even in Lines/Edit/Break)
  e.preventDefault();
  e.stopPropagation();

  dragCandidate = { node, pointerId: e.pointerId };

        // IMPORTANT: no setPointerCapture here, so pointerup still
        // bubbles through the node and handleNodePointerUp will fire
        // for simple taps (Lines/Edit modes).
  svg.addEventListener("pointermove", onCanvasPointerMove);
  svg.addEventListener("pointerup", onCanvasPointerUp, { once:true });
}




function onCanvasPointerMove(e){
  if (pressTimer && dist(e.clientX,e.clientY,downX,downY) > DRAG_MENU_CANCEL_PX) {
    cancelPressTimer();
  }

  if (linkingFrom && linkActive){
    const p = svgPoint(e);
    tempLink.setAttribute("x2", p.x);
    tempLink.setAttribute("y2", p.y);
    return;
  }

        // No active drag yet: turn candidate into real drag if moved enough
  if (!dragNode && dragCandidate && e.pointerId === dragCandidate.pointerId){
    const p = svgPoint(e);
    const node = dragCandidate.node;
    dragNode = node;
    dragOffset.x = node.x - p.x;
    dragOffset.y = node.y - p.y;
    dragCandidate = null;

    selectedNodeId = node.id;
    updateNodeGraphics();

    setStatus(`Dragging ${node.label}`);
  }

  if (!dragNode) return;

  const p = svgPoint(e);
  dragNode.x = p.x + dragOffset.x;
  dragNode.y = p.y + dragOffset.y;
  renderAll();

        // while dragging, show dot at the link we would insert into
  const best = findNearestLinkPoint(
    dragNode.x,
    dragNode.y,
    { maxDist: 24, ignoreNodeId: dragNode.id }
    );
  if (best) showHoverDotAt(best.info.x, best.info.y);
  else      hideHoverDot();
}

function onCanvasPointerUp(e){
  svg.removeEventListener("pointermove", onCanvasPointerMove);
  cancelPressTimer();
  dragCandidate = null;

  if (dragNode){
    const movedNode = dragNode;

          // see if this node was dropped onto a link (ignore links it already ends on)
    const best = findNearestLinkPoint(
      movedNode.x,
      movedNode.y,
      { maxDist: 24, ignoreNodeId: movedNode.id }
      );

          // first: finalize movement (records MOVE_NODE in history)
    moveNodeWrapped(movedNode);

          // then: if we had a link under us, split it using this node
    if (best){
      splitExistingLinkWithNode(movedNode, best);
    }

    dragNode = null;
  }

  hideHoverDot();
}


      // ----- Background: pan or tap-to-add node -----
svg.addEventListener("pointerdown", (e)=>{
  if (e.button === 2) e.preventDefault();

        // if click started on an existing node, do nothing here
  const nodeHit = e.target.closest(".node");
  if (nodeHit) return;

        // only act on raw SVG background, not layers/lines
  if (e.target !== svg) return;

        // If we are currently doing a two-finger pan, ignore taps
  if (touchPanActive) return;

        // Space + drag or middle mouse on background → pan (desktop)
  if (spacePressed || e.button === 1) {
    startPan(e);
    return;
  }

  if (!currentProject){ gateOn(); return; }
  if (linkingFrom){ cancelLinking(); setStatus("Link cancelled"); return; }

        // Start a tap candidate; we will only create the node on pointerup
  bgTapCandidate = {
    pointerId: e.pointerId,
    startX: e.clientX,
    startY: e.clientY
  };

  svg.setPointerCapture(e.pointerId);
  svg.addEventListener("pointermove", onBgPointerMove);
  svg.addEventListener("pointerup", onBgPointerUp, { once:true });
});

      // hover feedback: little white dot on the closest line
svg.addEventListener("pointermove", (e)=>{
  if (!currentProject) { hideHoverDot(); return; }

        // while dragging or linking or panning, let other logic handle it
  if (dragNode || dragCandidate || linkingFrom || isPanning || touchPanActive) {
          // dragNode case is handled in onCanvasPointerMove
    if (!dragNode) hideHoverDot();
    return;
  }

  const p = svgPoint(e);
  const best = findNearestLinkPoint(p.x, p.y, { maxDist: 18 });
  if (best) showHoverDotAt(best.info.x, best.info.y);
  else hideHoverDot();
});

svg.addEventListener("pointerleave", () => {
  hideHoverDot();
});

      // Combined pinch + pan (two-finger gesture) with debug center marker
let pinchActive = false;
let pinchStartDistance = 0;
let pinchStartZoom = 1;
let pinchStartViewBox = { x: 0, y: 0, w: 0, h: 0 };
      let pinchWorld = { x: 0, y: 0 };   // world-space anchor point

      const pinchCenterDot = document.getElementById("pinch-center");

      function getTouchDistance(e){
        if (e.touches.length < 2) return null;
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.hypot(dx, dy);
      }

      function getTouchMidpoint(e){
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        return {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2
        };
      }

      svg.addEventListener("touchstart", (e) => {
        if (e.touches.length === 2) {
          e.preventDefault();

          // Mark that a multi-touch gesture is active (also used to block bg taps)
          touchPanActive = true;

          pinchActive = true;
          pinchStartDistance = getTouchDistance(e) || 0.0001;
          pinchStartZoom = zoom;
          pinchStartViewBox = { x: viewBox.x, y: viewBox.y, w: viewBox.w, h: viewBox.h };

          const mid = getTouchMidpoint(e);

          // World coordinate under the midpoint at gesture start
          const svgMid = screenToSvg(mid.x, mid.y);
          pinchWorld.x = svgMid.x;
          pinchWorld.y = svgMid.y;

          // Show debug circle in WORLD coordinates (same space as nodes)
          if (pinchCenterDot) {
            pinchCenterDot.setAttribute("cx", pinchWorld.x);
            pinchCenterDot.setAttribute("cy", pinchWorld.y);
            pinchCenterDot.style.display = "block";
          }
        }
      }, { passive: false });

      svg.addEventListener("touchmove", (e) => {
        if (!pinchActive || e.touches.length !== 2) return;

        e.preventDefault();

        const dist = getTouchDistance(e);
        if (!dist) return;

        const rect = svg.getBoundingClientRect();
        const mid = getTouchMidpoint(e);

        // Scale relative to the gesture start
        let scale = dist / pinchStartDistance;
        let nextZoom = pinchStartZoom * scale;

        // Clamp zoom
        if (nextZoom < MIN_ZOOM) nextZoom = MIN_ZOOM;
        if (nextZoom > MAX_ZOOM) nextZoom = MAX_ZOOM;

        const zoomFactor = nextZoom / pinchStartZoom;
        if (zoomFactor === 0) return;

        // New viewBox size
        viewBox.w = pinchStartViewBox.w / zoomFactor;
        viewBox.h = pinchStartViewBox.h / zoomFactor;

        // Anchor the original world point (pinchWorld) under the current midpoint
        const normX = (mid.x - rect.left) / rect.width;
        const normY = (mid.y - rect.top) / rect.height;

        viewBox.x = pinchWorld.x - normX * viewBox.w;
        viewBox.y = pinchWorld.y - normY * viewBox.h;

        zoom = nextZoom;
        updateViewBox();
        updateZoomLabel();
        setStatus(`Zoom: ${(zoom * 100).toFixed(0)}%`);

        // Keep debug dot at the anchored world point
        if (pinchCenterDot) {
          pinchCenterDot.setAttribute("cx", pinchWorld.x);
          pinchCenterDot.setAttribute("cy", pinchWorld.y);
        }
      }, { passive: false });

      svg.addEventListener("touchend", (e) => {
        if (e.touches.length < 2) {
          pinchActive = false;
          touchPanActive = false;
          if (pinchCenterDot) {
            pinchCenterDot.style.display = "none";
          }
        }
      });




      svg.addEventListener("wheel", (e) => {
        // Trackpad "two-finger drag" also comes in as wheel events.
        // Prevent page scroll and use it for pan / zoom.
        e.preventDefault();

        const rect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / rect.width;
        const scaleY = viewBox.h / rect.height;

        // Hold Ctrl/⌘ to zoom, otherwise pan.
        if (e.ctrlKey || e.metaKey) {
          const factor = e.deltaY < 0 ? ZOOM_STEP : 1 / ZOOM_STEP;
          applyZoomFactor(factor, e.clientX, e.clientY);
        } else {
          // Pan based on wheel deltas (works nicely with trackpad two-finger scroll)
          viewBox.x += e.deltaX * scaleX;
          viewBox.y += e.deltaY * scaleY;
          updateViewBox();
          setStatus("Panning (trackpad)");
        }
      }, { passive: false });


      function onBgPointerMove(e){
        if (!bgTapCandidate || e.pointerId !== bgTapCandidate.pointerId) return;
        const dx = e.clientX - bgTapCandidate.startX;
        const dy = e.clientY - bgTapCandidate.startY;
        if (Math.hypot(dx, dy) > BG_TAP_CANCEL_PX) {
          // too much movement → not a tap
          bgTapCandidate = null;
        }
      }

      function onBgPointerUp(e){
        svg.removeEventListener("pointermove", onBgPointerMove);
        try {
          svg.releasePointerCapture(e.pointerId);
        } catch(_) {}

        if (!bgTapCandidate || e.pointerId !== bgTapCandidate.pointerId){
          bgTapCandidate = null;
          return;
        }

        // If a two-finger pan was active during this gesture, do not add a node
        if (touchPanActive) {
          bgTapCandidate = null;
          return;
        }

        if (!currentProject){
          bgTapCandidate = null;
          return;
        }



        const p = svgPoint(e);

        // Break mode: tapping near a line removes that link instead of adding a node
        if (breakMode) {
          deleteNearestLinkAt(p.x, p.y);
          bgTapCandidate = null;
          return;
        }

        // 1) first try: insert node on an existing link (gateway)
        if (insertNodeOnNearestLink(p.x, p.y)){
          bgTapCandidate = null;
          return;
        }

        // 2) fallback: normal "add node in empty space"
        const nearExisting = nodes.some(n => dist(n.x, n.y, p.x, p.y) < 32);
        if (!nearExisting) {
          addNodeWrapped(p.x, p.y);
        }

        bgTapCandidate = null;



      }



      gate.addEventListener("pointerdown", (e) => {
        if (e.target === gate) {
          gateOff();
        }
      });      

      // ----- Linking (desktop + touch) -----
      function startConnectionFrom(node, opts={}){
        if (!node) return;

        selectedNodeId = node.id;
        updateNodeGraphics();

        linkingFrom = node;
        tempLink.setAttribute("x1", node.x);
        tempLink.setAttribute("y1", node.y);
        tempLink.setAttribute("x2", node.x);
        tempLink.setAttribute("y2", node.y);
        tempLink.style.display = "block";

        if (opts.immediateFollow){
          linkActive = true;
          svg.addEventListener("pointermove", onCanvasPointerMove);
          setStatus(`Connecting from ${node.label}: move cursor, click a node to finish`);
        } else {
          setStatus(`Connecting from ${node.label}: touch canvas to start, lift on target node`);
          svg.addEventListener("pointerdown", onLinkPointerDown, { once:true });
        }
      }

      function onLinkPointerDown(e){
        if (!linkingFrom) return;
        e.preventDefault();
        linkActive = true;
        const p = svgPoint(e);
        tempLink.setAttribute("x2", p.x);
        tempLink.setAttribute("y2", p.y);
        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onCanvasPointerMove);
        svg.addEventListener("pointerup", onLinkPointerUp, { once:true });
      }

      function onLinkPointerUp(e){
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        linkActive = false;

        const hit = document.elementFromPoint(e.clientX, e.clientY);
        let group = hit && hit.closest ? hit.closest(".node") : null;
        if (group && linkingFrom){
          const toId = Number(group.dataset.id);
          if (toId && toId !== linkingFrom.id){ connectNodesWrapped(linkingFrom.id, toId); }
        }
        cancelLinking();
      }

      function cancelLinking(){
        linkingFrom = null;
        linkActive = false;
        tempLink.style.display = "none";
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        svg.removeEventListener("pointerdown", onLinkPointerDown);
        hideHoverDot();
      }


      // prevent context menu while dragging/linking
      nodesLayer.addEventListener("contextmenu", (e)=>{
        if (dragNode || linkingFrom){ e.preventDefault(); e.stopPropagation(); }
      });

      svg.addEventListener("contextmenu", (e)=>{
        if (dragNode || linkingFrom){ e.preventDefault(); }
      });

      // ----- Palette (anchored color input) -----
      function renderPalette(){
        paletteEl.innerHTML = "";

        palette.colors.slice(0,4).forEach((c, i)=>{
          const sw = document.createElement("div");
          sw.className = "swatch" + (palette.selected===i ? " selected" : "");
          sw.style.background = c;
          sw.title = `Color ${i+1}`;
          sw.addEventListener("click", ()=>{
            palette.selected = i;
            paletteEl.querySelectorAll(".swatch").forEach((el, idx)=>{
              if (!el.classList) return;
              if (idx === i) el.classList.add("selected");
              else el.classList.remove("selected");
            });
            updateProjectMeta({ palette });
            if (lastHoverNode) restyleNodeWrapped(lastHoverNode, { fill: palette.colors[i], stroke: palette.colors[i] });
            positionColorInput();
          });
          paletteEl.appendChild(sw);
        });

        const pickerBtn = document.createElement("div");
        pickerBtn.className = "swatch picker";
        pickerBtn.title = "Pick a color";
        pickerBtn.innerHTML = "<span>＋</span>";
        pickerBtn.addEventListener("click", () => {
          colorInput.value = normHex(palette.colors[palette.selected] || '#3b82f6');
          colorInput.click();
        });
        paletteEl.appendChild(pickerBtn);
      }

      function positionColorInput(){
        const plus = paletteEl.querySelector(".swatch.picker");
        if (!plus) return;
        const r = plus.getBoundingClientRect();
        Object.assign(colorInput.style, {
          left: (r.left) + "px",
          top:  (r.top)  + "px",
          width: r.width + "px",
          height:r.height+ "px",
          display: "block"
        });
      }

      colorInput.addEventListener("input", (e)=>{
        const val = normHex(e.target.value);
        const idx = palette.selected || 0;
        palette.colors[idx] = val;
        const sw = paletteEl.querySelectorAll(".swatch")[idx];
        if (sw) sw.style.background = val;
        if (lastHoverNode) restyleNodeWrapped(lastHoverNode, { fill: val, stroke: val });
        setStatus(`Preview color #${idx+1} → ${val}`);
      });

      colorInput.addEventListener("change", async (e)=>{
        const val = normHex(e.target.value);
        const idx = palette.selected || 0;
        palette.colors[idx] = val;
        await updateProjectMeta({ palette });
        renderPalette();
        setStatus(`Color saved #${idx+1} → ${val}`);
      });

      window.addEventListener("resize", positionColorInput);

      descCancelBtn.addEventListener("click", closeDescriptionModal);
      descSaveBtn.addEventListener("click", ()=>{
        if (!descNode) { closeDescriptionModal(); return; }
        setNodeDescription(descNode, descText.value);
        closeDescriptionModal();
      });

      descOverlay.addEventListener("pointerdown", (e)=>{
        if (e.target === descOverlay) closeDescriptionModal();
      });

      renameCancel.addEventListener("click", closeRenameModal);
      renameSave.addEventListener("click", ()=>{
        if (!renameNodeRef) { closeRenameModal(); return; }
        const val = (renameInput.value || "").trim();
        if (val) {
          renameNodeWrapped(renameNodeRef, val);
        }
        closeRenameModal();
      });

      renameInput.addEventListener("keydown", (e)=>{
        if (e.key === "Enter") {
          e.preventDefault();
          renameSave.click();
        }
        if (e.key === "Escape") {
          e.preventDefault();
          closeRenameModal();
        }
      });

      renameOverlay.addEventListener("pointerdown", (e)=>{
        if (e.target === renameOverlay) closeRenameModal();
      });

      // ----- Sidebar toggle -----
      let sidebarOpen = false;
      btnHelp.addEventListener("click", ()=>{
        sidebarOpen = !sidebarOpen;
        sidebar.style.display = sidebarOpen ? "flex" : "none";
      });
      btnHelp.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && sidebarOpen){ sidebarOpen=false; sidebar.style.display="none"; } });

      /* ----- Mobile UI behavior ----- */
      hamburger.addEventListener("click", ()=>{
        hambMenu.style.display = (hambMenu.style.display==="block") ? "none" : "block";
      });


      document.addEventListener("pointerdown", (e)=>{
        const target = e.target;

        // Close hamburger menu when clicking outside
        if (!hambMenu.contains(target) && target !== hamburger){
          hambMenu.style.display = "none";
        }

        // Close hint/sidebar when clicking outside it
        if (sidebarOpen && !sidebar.contains(target) && target !== btnHelp){
          sidebarOpen = false;
          sidebar.style.display = "none";
        }
      });


      hambMenu.addEventListener("click", async (e)=>{
        const b = e.target.closest("button");
        if (!b) return;

        const act = b.getAttribute("data-mobile");

        if (act === "open") {
          await refreshProjectList();
          gateOn();
          setStatus("Open project");

        } else if (act === "new") {
          const res = await promptDialog("New project name:", "", "New project");
          if (!res.ok) {
            hambMenu.style.display = "none";
            return;
          }
          const name = (res.value || "").trim();
          if (!name) {
            hambMenu.style.display = "none";
            return;
          }
          try {
            const p = await createProject(name);
            await refreshProjectList();
            await openProject(p);
          } catch (err) {
            setStatus("Create failed (name exists?)");
          }

        } else if (act === "dup") {
          if (!currentProject) {
            setStatus("No project to duplicate");
          } else {
            const res = await promptDialog(
          `Clone "${currentProject.name}" as:`,
        `${currentProject.name} (copy)`,
        "Clone project"
        );
            if (res.ok) {
              const name = (res.value || "").trim();
              if (name) {
                await confirmSaveIfDirty();
                try {
                  const dup = await duplicateProject(currentProject.id, name);
                  await refreshProjectList();
                  await openProject(dup);
                  setStatus(`Cloned as "${dup.name}"`);
                } catch (err) {
                  setStatus("Clone failed (name exists?)");
                }
              }
            }
          }

        } else if (act === "del") {
          if (currentProject) {
            const res = await confirmDialog(
          `Delete project "${currentProject.name}"?\n\nThis cannot be undone.`,
          "Delete project"
          );
            if (res.ok) {
              await deleteProject(currentProject.id);
              await refreshProjectList();
              gateOn();
            }
          }

        } else if (act === "save") {
          await persistSnapshot();

        } else if (act === "export") {
          if (!currentProject) {
            setStatus("No project to export");
          } else {
            await exportSingleProject(currentProject.id);
          }

        } else if (act === "import") {
          if (projectImportFile) {
            projectImportFile.click();
          }




        } else if (act === "clear-lines") {
          if (!currentProject) {
            setStatus("Create/open a project first");
          } else if (!links.length) {
            setStatus("No lines to clear");
          } else {
            const res = await confirmDialog(
              "Remove all connections between nodes in this project?\n\nNodes will stay where they are.",
              "Clear lines"
              );
            if (res.ok) clearLinksOnlyWrapped();
          }

        } else if (act === "clear-all") {
          if (!currentProject) {
            setStatus("Create/open a project first");
          } else if (!nodes.length && !links.length) {
            setStatus("Nothing to clear");
          } else {
            const res = await confirmDialog(
              "Clear all nodes and connections in this project?\n\nYou can still Undo while this session stays open.",
              "Clear all"
              );
            if (res.ok) clearAllNodesAndLinksWrapped();
          }

        } else if (act === "hint") {
          btnHelp.click();

        } else if (act === "config") {
          showConfigOverlay();

        } else if (act === "layouts") {
          showLayoutOverlay();
        }

        hambMenu.style.display = "none";
      });






      projectClose.addEventListener("click", () => {
        gateOff();
      });


      zoomInBtn.addEventListener("click", () => {
        applyZoomFactor(ZOOM_STEP);
      });

      zoomOutBtn.addEventListener("click", () => {
        applyZoomFactor(1 / ZOOM_STEP);
      });

      zoomResetBtn.addEventListener("click", () => {
        resetZoomTo100();
      });

      zoomFitBtn.addEventListener("click", () => {
        zoomToFit();
      });


      function syncToolButtons(){
        toolLines.classList.toggle("active",  linesMode);
        toolEdit.classList.toggle("active",   editMode);
        toolBreak.classList.toggle("active",  breakMode);
        toolDelete.classList.toggle("active", deleteMode);
      }

      toolLines.addEventListener("click", ()=>{
        linesMode = !linesMode;
        if (linesMode){
          editMode   = false;
          breakMode  = false;
          deleteMode = false;
          chainFrom  = null;
        } else {
          chainFrom = null;
        }
        syncToolButtons();
        setStatus(linesMode ? "Lines mode: tap nodes to chain" : "Lines mode off");
      });

      toolEdit.addEventListener("click", ()=>{
        editMode = !editMode;
        if (editMode){
          linesMode  = false;
          breakMode  = false;
          deleteMode = false;
          chainFrom  = null;
        }
        syncToolButtons();
        setStatus(editMode ? "Edit mode: tap a node for menu" : "Edit mode off");
      });

      toolBreak.addEventListener("click", ()=>{
        breakMode = !breakMode;
        if (breakMode){
          linesMode  = false;
          editMode   = false;
          deleteMode = false;
          chainFrom  = null;
        }
        syncToolButtons();
        setStatus(breakMode ? "Break mode: tap near a line to remove it" : "Break mode off");
      });

      toolDelete.addEventListener("click", ()=>{
        deleteMode = !deleteMode;
        if (deleteMode){
          linesMode  = false;
          editMode   = false;
          breakMode  = false;
          chainFrom  = null;
        }
        syncToolButtons();
        setStatus(deleteMode ? "Delete mode: tap a node to remove" : "Delete mode off");
      });

      syncToolButtons();

      // Node tap handler for Lines/Edit/Delete modes
      function handleNodePointerUp(e, node){
        if (tapMoved) return;
        if (!currentProject) return;
        if (deleteMode){
          deleteNodeWrapped(node);
          return;
        }

        if (linesMode){
          if (!chainFrom){
            chainFrom = node;
            selectedNodeId = node.id;
            updateNodeGraphics();
            setStatus(`Chain start: ${node.label}`);
            return;
          }
          if (chainFrom.id !== node.id){
            connectNodesWrapped(chainFrom.id, node.id);
            setStatus(`Linked ${chainFrom.label} → ${node.label}`);
          }
          chainFrom = node;
          selectedNodeId = node.id;
          updateNodeGraphics();
          return;
        }

        if (editMode){
          const fake = { preventDefault: ()=>{}, clientX: e.clientX, clientY: e.clientY };
          openMenu(fake, node);
          return;
        }
      }

      // Two-finger long-press to open menu (touch)
      let twoFingerTimer = null;
      function maybeTwoFingerMenu(e, node){
        if (!editMode && e.touches && e.touches.length===2){
          e.preventDefault();
          clearTwoFingerTimer();
          const t = e.touches[0];
          twoFingerTimer = setTimeout(()=>{
            const fake = { preventDefault: ()=>{}, clientX: t.clientX, clientY: t.clientY };
            openMenu(fake, node);
          }, LONG_PRESS_MS);
        }
      }
      function clearTwoFingerTimer(){ if (twoFingerTimer){ clearTimeout(twoFingerTimer); twoFingerTimer=null; } }

      // ----- Gate & boot -----
      function gateOn(){ gate.style.display = "flex"; gateCover.style.display = "block"; }
      function gateOff(){ gate.style.display = "none"; gateCover.style.display = "none"; }


      async function refreshProjectList(){
        const items = await listProjects();
        projectListItems = items;   // cache for the delegated handler

        listEl.innerHTML = "";

        if (items.length === 0){
          const d = document.createElement("div");
          d.className = "proj-row";
          d.innerHTML = `<span class="proj-meta">No projects yet.</span>`;
          listEl.appendChild(d);
          return;
        }

        items.forEach(p=>{
          const row = document.createElement("div");
          row.className = "proj-row";
          row.innerHTML = `
            <div>
              <div class="proj-name">${p.name}</div>
              <div class="proj-meta">Updated: ${new Date(p.updatedAt || p.createdAt).toLocaleString()}</div>
            </div>
            <div class="row-actions">
              <button class="btn primary" data-open="${p.id}">Open</button>
              <button class="btn" data-dup="${p.id}">Clone</button>
              <button class="btn" data-export="${p.id}">Export</button>
              <button class="btn danger" data-del="${p.id}">Delete</button>
          </div>`;
          listEl.appendChild(row);
        });

      }




      listEl.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-open],button[data-dup],button[data-del],button[data-export]");
        if (!btn) return;

        const id   = Number(btn.dataset.open || btn.dataset.dup || btn.dataset.del || btn.dataset.export);
        const proj = projectListItems.find(x => x.id === id);
        if (!proj) return;

        // Open
        if (btn.dataset.open !== undefined) {
          await confirmSaveIfDirty();
          await openProject(proj);
          return;
        }

        // Clone
        if (btn.dataset.dup !== undefined) {
          const res = await promptDialog(
        `Name for the duplicate of "${proj.name}":`,
      `${proj.name} (copy)`,
      "Clone project"
      );
          if (!res.ok) return;
          const name = (res.value || "").trim();
          if (!name) return;

          if (currentProject && proj.id === currentProject.id) {
            await confirmSaveIfDirty();
          }

          try {
            const dup = await duplicateProject(proj.id, name);
            await refreshProjectList();
            await openProject(dup);
            setStatus(`Cloned as "${dup.name}"`);
          } catch (err) {
            console.error("Clone from project list failed", err);
            setStatus("Clone failed (name exists?)");
          }
          return;
        }

        // Delete
        if (btn.dataset.del !== undefined) {
          const res = await confirmDialog(
        `Delete project "${proj.name}"?\n\nThis cannot be undone.`,
        "Delete project"
        );
          if (!res.ok) return;

          await deleteProject(proj.id);
          await refreshProjectList();
          setStatus(`Project "${proj.name}" deleted`);
          return;
        }

        // Export single project
        if (btn.dataset.export !== undefined) {
          await exportSingleProject(proj.id);
          return;
        }
      });




      async function deleteProject(id){
        await new Promise((res,rej)=>{
          const t = tx(["projects","states","history"],"readwrite");
          t.objectStore("projects").delete(id);
          const s = t.objectStore("states").index("by_project").openCursor(IDBKeyRange.only(id));
          s.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("states").delete([id,c.value.rev]); c.continue(); } };
          const h = t.objectStore("history").index("by_project").openCursor(IDBKeyRange.only(id));
          h.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("history").delete([id,c.value.seq]); c.continue(); } };
          t.oncomplete=()=>res(); t.onerror=()=>rej(t.error);
        });
        if (currentProject && currentProject.id===id){ currentProject=null; gateOn(); clearGraph(); setStatus("Project deleted"); }
      }

      async function openProject(pMeta){
        currentProject = pMeta;
        projLabel.textContent = currentProject.name;
        palette = (pMeta.palette && Array.isArray(pMeta.palette.colors))
        ? { colors:[...pMeta.palette.colors], selected: Number(pMeta.palette.selected)||0 }
        : { colors:['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected:0 };
        renderPalette();

        const latest = await loadLatestState(currentProject.id);
        applyState(latest.state);
        await rebuildStacksFromHistory();
        hasUnsavedChanges = false;
        gateOff();
        setStatus(`Project opened: ${currentProject.name} | Nodes: ${nodes.length} | Links: ${links.length}`);
      }


      btnSwitch.addEventListener("click", async ()=>{ await refreshProjectList(); gateOn(); setStatus("Open project"); });
      btnNew.addEventListener("click", async ()=>{
        const name = prompt("New project name:"); if (!name || !name.trim()) return;
        try{ const p = await createProject(name.trim()); await refreshProjectList(); await openProject(p); }catch(e){ setStatus("Create failed (name exists?)"); }
      });


      btnDup.addEventListener("click", async ()=>{
        if (!currentProject) { setStatus("No project to duplicate"); return; }

        const name = prompt(
      `Clone "${currentProject.name}" as:`,
    `${currentProject.name} (copy)`
    );
        if (!name || !name.trim()) return;

        await confirmSaveIfDirty();

        try {
          const dup = await duplicateProject(currentProject.id, name.trim());
          await refreshProjectList();
          await openProject(dup);
          setStatus(`Cloned as "${dup.name}"`);
        } catch(e) {
          setStatus("Clone failed (name exists?)");
        }
      });




      btnDel.addEventListener("click", async ()=>{
        if (!currentProject) return;
        const ok = confirm(`Delete project "${currentProject.name}"? This cannot be undone.`); if (!ok) return;
        await deleteProject(currentProject.id); await refreshProjectList(); gateOn();
      });

      createBtn.addEventListener("click", async ()=>{
        const name = (projNameInput.value||"").trim(); if (!name) return;
        try{ const p = await createProject(name); projNameInput.value = ""; await refreshProjectList(); await openProject(p); }
        catch(e){ setStatus("Project create error (name exists?)"); }
      });

      btnUndo.addEventListener("click", doUndo);
      btnRedo.addEventListener("click", doRedo);
      btnSave.addEventListener("click", persistSnapshot);


      if (projectImportBtn && projectImportFile) {
        projectImportBtn.addEventListener("click", () => {
          projectImportFile.click();
        });

        projectImportFile.addEventListener("change", async () => {
          const file = projectImportFile.files && projectImportFile.files[0];
          if (!file) return;

          try {
            const text = await file.text();
            const data = JSON.parse(text);
            await importBackupData(data, "merge");
          } catch (e) {
            console.error("Project import failed", e);
            alert("Failed to import project file.");
          } finally {
            projectImportFile.value = "";
          }
        });
      }


      // NEW: topbar Clear Lines
      if (btnClearLines) {
        btnClearLines.addEventListener("click", () => {
          if (!currentProject) {
            setStatus("Create/open a project first");
            return;
          }
          if (!links.length) {
            setStatus("No lines to clear");
            return;
          }
          const ok = confirm(
            "Remove all connections between nodes in this project?\n\nNodes will stay where they are."
            );
          if (!ok) return;
          clearLinksOnlyWrapped();
        });
      }

      // NEW: topbar Clear (nodes + lines)
      if (btnClear) {
        btnClear.addEventListener("click", () => {
          if (!currentProject) {
            setStatus("Create/open a project first");
            return;
          }
          if (!nodes.length && !links.length) {
            setStatus("Nothing to clear");
            return;
          }
          const ok = confirm(
            "Clear all nodes and connections in this project?\n\nYou can still Undo while this session stays open."
            );
          if (!ok) return;
          clearAllNodesAndLinksWrapped();
        });
      }




      function clearGraph(){
        nodes = [];
        links = [];
        nextId = 1;
        hasUnsavedChanges = false;
        renderAll();
        projLabel.textContent = "—";
      }

      function clearLinksOnlyWrapped(){
        if (!links.length) {
          setStatus("No lines to clear");
          return;
        }
        links = [];
        renderLinks();
        pushAction({ type: "CLEAR_LINKS", at: Date.now() });
        setStatus("All connections cleared (nodes kept)");
      }

      function clearAllNodesAndLinksWrapped(){
        if (!nodes.length && !links.length) {
          setStatus("Nothing to clear");
          return;
        }
        nodes = [];
        links = [];
        nextId = 1;
        selectedNodeId = null;
        renderAll();
        pushAction({ type: "CLEAR_ALL", at: Date.now() });
        setStatus("All nodes and connections cleared");
      }



      /* Config */

      if (btnConfig) {
        btnConfig.addEventListener("click", () => {
          console.log("[config] Topbar Config button clicked");
          showConfigOverlay();
        });
      }

      if (configCloseBtn) {
        configCloseBtn.addEventListener("click", () => {
          console.log("[config] Close button clicked");
          hideConfigOverlay();
        });
      }

      if (configOverlay) {
        configOverlay.addEventListener("pointerdown", (e) => {
          if (e.target === configOverlay) {
            console.log("[config] Backdrop clicked");
            hideConfigOverlay();
          }
        });
      }

      async function exportSingleProject(projectId){
        if (!db){
          setStatus("No database open to export");
          return;
        }

        // project meta
        const project = await new Promise((res, rej) => {
          const t = tx(["projects"]);
          const store = t.objectStore("projects");
          const req = store.get(projectId);
          req.onsuccess = () => res(req.result || null);
          req.onerror   = () => rej(req.error);
        });

        if (!project){
          setStatus("Project not found");
          return;
        }

        const payload = {
          dbName: DB_NAME,
          version: DB_VER,
          exportedAt: new Date().toISOString(),
          projects: [project],
          states: [],
          history: []
        };

        // states for this project
        await new Promise((res, rej) => {
          const t = tx(["states"]);
          const idx = t.objectStore("states").index("by_project")
          .openCursor(IDBKeyRange.only(projectId));
          idx.onsuccess = (e) => {
            const cur = e.target.result;
            if (cur){
              payload.states.push(cur.value);
              cur.continue();
            } else {
              res();
            }
          };
          idx.onerror = () => rej(idx.error);
        });

        // history for this project
        await new Promise((res, rej) => {
          const t = tx(["history"]);
          const idx = t.objectStore("history").index("by_project")
          .openCursor(IDBKeyRange.only(projectId));
          idx.onsuccess = (e) => {
            const cur = e.target.result;
            if (cur){
              payload.history.push(cur.value);
              cur.continue();
            } else {
              res();
            }
          };
          idx.onerror = () => rej(idx.error);
        });

        try {
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type:"application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          const safeName = (project.name || "project").replace(/[^\w\-]+/g, "_");
          a.href = url;
          a.download = `node-canvas-project-${safeName}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          setStatus(`Exported "${project.name}" to file`);
        } catch (err) {
          console.error("exportSingleProject error", err);
          setStatus("Failed to export project");
        }
      }

      async function exportAllData(){
        console.log("[config] exportAllData: start");
        if (!db){
          setStatus("No database open to export");
          console.log("[config] exportAllData: no db");
          return;
        }

        const payload = {
          dbName: DB_NAME,
          version: DB_VER,
          exportedAt: new Date().toISOString(),
          projects: [],
          states: [],
          history: []
        };

        const stores = [
          { name:"projects", key:"projects" },
          { name:"states",   key:"states"   },
          { name:"history",  key:"history"  }
        ];

        for (const info of stores){
          await new Promise((res, rej) => {
            const t = tx([info.name]);
            const s = t.objectStore(info.name);
            const req = s.openCursor();
            req.onsuccess = (e) => {
              const cur = e.target.result;
              if (cur){
                payload[info.key].push(cur.value);
                cur.continue();
              } else {
                res();
              }
            };
            req.onerror = () => rej(req.error);
          });
        }

        try {
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type:"application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          const ts = new Date().toISOString().replace(/[:.]/g,"-");
          a.href = url;
          a.download = `node-canvas-backup-${ts}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          setStatus("Exported data to JSON file");
          console.log("[config] exportAllData: success");
        } catch (err) {
          console.error("[config] exportAllData: error", err);
          setStatus("Failed to export data");
        }
      }

      async function importBackupData(data, mode){
        console.log("[config] importBackupData: start", { mode });
        if (!data || !Array.isArray(data.projects) || !Array.isArray(data.states) || !Array.isArray(data.history)){
          alert("Backup file format not recognized.");
          console.log("[config] importBackupData: invalid format");
          return;
        }

        const confirmMsg = mode === "merge"
        ? "Import and merge this data with existing projects?"
        : "Replace ALL existing data with this backup? This cannot be undone.";
        const ok = confirm(confirmMsg);
        if (!ok) {
          console.log("[config] importBackupData: user cancelled");
          return;
        }

        if (mode === "replace"){
          if (db){
            db.close();
            db = null;
          }
          await new Promise((res, rej) => {
            const req = indexedDB.deleteDatabase(DB_NAME);
            req.onsuccess = () => res();
            req.onerror   = () => rej(req.error);
            req.onblocked = () => res();
          });
          db = await openDB();
          console.log("[config] importBackupData: existing db cleared and reopened");
        } else {
          if (!db) db = await openDB();
        }

        const importedProjects = data.projects || [];
        const importedStates   = data.states || [];
        const importedHistory  = data.history || [];

        const idMap = new Map();
        let offset = 0;

        if (mode === "merge"){
          const existing = await listProjects();
          let maxId = 0;
          existing.forEach(p => {
            if (typeof p.id === "number" && p.id > maxId) maxId = p.id;
          });
          offset = maxId;
          console.log("[config] importBackupData: merge offset", offset);
        }

        await new Promise((res, rej) => {
          const t = tx(["projects","states","history"], "readwrite");
          const projStore = t.objectStore("projects");
          const stateStore= t.objectStore("states");
          const histStore = t.objectStore("history");

          if (mode === "replace"){
            projStore.clear();
            stateStore.clear();
            histStore.clear();
          }

          importedProjects.forEach(p => {
            const oldId = p.id;
            const newId = mode === "merge" ? (oldId + offset) : oldId;
            idMap.set(oldId, newId);
            const rec = { ...p, id:newId };
            projStore.put(rec);
          });

          importedStates.forEach(s => {
            const oldPid = s.projectId;
            if (oldPid == null) return;
            const newPid = mode === "merge"
            ? (idMap.get(oldPid) ?? (oldPid + offset))
            : oldPid;
            if (mode === "merge" && !idMap.has(oldPid)){
              idMap.set(oldPid, newPid);
            }
            const rec = { ...s, projectId:newPid };
            stateStore.put(rec);
          });

          importedHistory.forEach(h => {
            const oldPid = h.projectId;
            if (oldPid == null) return;
            const newPid = mode === "merge"
            ? (idMap.get(oldPid) ?? (oldPid + offset))
            : oldPid;
            const rec = { ...h, projectId:newPid };
            histStore.put(rec);
          });

          t.oncomplete = () => res();
          t.onerror    = () => rej(t.error);
        });

        await refreshProjectList();
        gateOn();
        clearGraph();
        setStatus("Import complete");
        console.log("[config] importBackupData: completed", { mode });
      }

      if (configImportRun && configImportFile) {
        configImportRun.addEventListener("click", () => {
          console.log("[config] Import button clicked");
          const file = configImportFile.files && configImportFile.files[0];
          if (!file) {
            console.log("[config] Import: no file selected, opening picker");
            configImportFile.click();
            return;
          }
          runImportFromFile();
        });

        configImportFile.addEventListener("change", () => {
          const file = configImportFile.files && configImportFile.files[0];
          if (!file) return;
          console.log("[config] File chosen via picker, running import");
          runImportFromFile();
        });

        async function runImportFromFile() {
          const file = configImportFile.files && configImportFile.files[0];
          if (!file) {
            console.log("[config] runImportFromFile: no file present");
            return;
          }

          let mode = "replace";
          const modeInput = document.querySelector('input[name="import-mode"]:checked');
          if (modeInput) mode = modeInput.value;

          try {
            const text = await file.text();
            const data = JSON.parse(text);
            await importBackupData(data, mode);
          } catch (e) {
            console.error("[config] Import: failed to import backup", e);
            alert("Failed to import backup.");
          } finally {
            configImportFile.value = "";
          }
        }
      }

      if (configDbRefresh) {
        configDbRefresh.addEventListener("click", () => {
          console.log("[config] Recalculate size clicked");
          refreshDbSizeLabel();
        });
      }

      if (configDbClear) {
        configDbClear.addEventListener("click", () => {
          console.log("[config] Clear database clicked");
          clearIndexedDB();
        });
      }

      if (configExportBtn) {
        configExportBtn.addEventListener("click", () => {
          console.log("[config] Export data clicked");
          exportAllData();
        });
      }

      if (configThemeToggle) {
        configThemeToggle.addEventListener("click", () => {
          const root = document.documentElement;
          const current = root.dataset.theme === "light" ? "light" : "dark";
          const next = current === "light" ? "dark" : "light";
          console.log("[config] Theme toggle clicked", { current, next });
          applyTheme(next);
          try {
            localStorage.setItem(THEME_KEY, next);
          } catch (err) {
            console.warn("[config] Theme toggle: failed to persist theme", err);
          }
        });
      }

      function clearIndexedDB(){
        console.log("[config] clearIndexedDB: start");
        const ok = confirm("Clear all Node Canvas data from this browser? This cannot be undone.");
        if (!ok) {
          console.log("[config] clearIndexedDB: user cancelled");
          return;
        }
        if (db){
          db.close();
          db = null;
        }
        const req = indexedDB.deleteDatabase(DB_NAME);
        req.onsuccess = () => {
          setStatus("Database cleared");
          console.log("[config] clearIndexedDB: success, reloading");
          location.reload();
        };
        req.onerror = () => {
          setStatus("Failed to clear database");
          console.error("[config] clearIndexedDB: error", req.error);
        };
        req.onblocked = () => {
          setStatus("Database clear blocked by another tab");
          console.warn("[config] clearIndexedDB: blocked");
        };
      }

      async function estimateDBSizeBytes(){
        console.log("[config] estimateDBSizeBytes: start");
        if (!db) {
          console.log("[config] estimateDBSizeBytes: no db");
          return 0;
        }
        const stores = ["projects","states","history"];
        let total = 0;
        for (const store of stores){
          await new Promise((res, rej) => {
            const t = tx([store]);
            const s = t.objectStore(store);
            const req = s.openCursor();
            req.onsuccess = (e) => {
              const cur = e.target.result;
              if (cur){
                try {
                  total += JSON.stringify(cur.value).length;
                } catch(_) {}
                cur.continue();
              } else {
                res();
              }
            };
            req.onerror = () => rej(req.error);
          });
        }
        console.log("[config] estimateDBSizeBytes: done", { bytes: total });
        return total;
      }

      async function refreshDbSizeLabel(){
        if (!configDbSize) return;
        configDbSize.textContent = "IndexedDB usage: calculating…";
        try{
          const bytes = await estimateDBSizeBytes();
          let human;
          if (bytes < 1024) human = `${bytes} B`;
          else if (bytes < 1024*1024) human = `${(bytes/1024).toFixed(1)} KB`;
          else human = `${(bytes/1024/1024).toFixed(2)} MB`;
          configDbSize.textContent = `IndexedDB usage (approx.): ${human}`;
          console.log("[config] refreshDbSizeLabel:", { bytes, human });
        }catch(e){
          configDbSize.textContent = "IndexedDB usage: n/a";
          console.error("[config] refreshDbSizeLabel: error", e);
        }
      }

      function showConfigOverlay(){
        if (!configOverlay) {
          console.warn("[config] showConfigOverlay: overlay missing");
          return;
        }
        console.log("[config] showConfigOverlay");
        configOverlay.style.display = "flex";
        refreshDbSizeLabel();
      }

      function hideConfigOverlay(){
        if (!configOverlay) return;
        console.log("[config] hideConfigOverlay");
        configOverlay.style.display = "none";
      }

      function applyTheme(theme){
        const root = document.documentElement;
        root.dataset.theme = theme;
        if (configThemeToggle){
          configThemeToggle.textContent = theme === "light" ? "Theme: Light" : "Theme: Dark";
        }
        console.log("[config] applyTheme", { theme });
      }

      function initTheme(){
        let theme;
        try {
          theme = localStorage.getItem(THEME_KEY);
        } catch (err) {
          console.warn("[config] initTheme: failed to read localStorage", err);
        }
        if (theme !== "light" && theme !== "dark") theme = "dark";
        console.log("[config] initTheme", { theme });
        applyTheme(theme);
      }

      async function boot(){
        console.log("[boot] start");
        svg.style.touchAction = "none";

        initTheme();

        db = await openDB();
        console.log("[boot] db opened");

        await refreshProjectList();
        gateOn();
        clearGraph();
        renderPalette();

        initViewBox();
        updateZoomLabel();

        requestAnimationFrame(positionColorInput);
        setStatus("Mode: create/open a project");

        window.addEventListener("resize", () => {
          const rect = svg.getBoundingClientRect();
          if (!rect.width || !rect.height) {
            positionColorInput();
            return;
          }

          // keep current world center
          const cx = viewBox.x + viewBox.w / 2;
          const cy = viewBox.y + viewBox.h / 2;

          // update "base" size used for zoom=1
          baseViewBox.w = rect.width;
          baseViewBox.h = rect.height;

          // recompute viewBox size from current zoom
          // zoom is defined as baseViewBox.w / viewBox.w
          viewBox.w = baseViewBox.w / zoom;
          viewBox.h = baseViewBox.h / zoom;

          // keep same center in world coordinates
          viewBox.x = cx - viewBox.w / 2;
          viewBox.y = cy - viewBox.h / 2;

          updateViewBox();
          updateZoomLabel();
          positionColorInput();
        });


        console.log("[boot] complete");
      }

      boot();


    })();


  </script>

</body>
</html>
