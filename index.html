<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#13141a">
  <link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;Node Canvas&quot;,&quot;display&quot;:&quot;standalone&quot;}">
  <title>Node Editor — projects, persistence, history (IndexedDB)</title>

  <style>
    /* Base + mobile hygiene */
    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { height:100%; }
    :root{
      --bg:#13141a; --panel:#1b1c25; --muted:#242633; --muted-2:#343647; --text:#e5e7eb;
      --pill:#0f172a; --pill-b:#334155; --shadow:rgba(0,0,0,.4);
      --fs:16px;
    }
    * { -webkit-tap-highlight-color: transparent; -webkit-user-select: none; user-select: none; }
    body { overscroll-behavior: none; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      font-size: var(--fs);
      background:var(--bg); color:var(--text);
      height:100vh; display:flex;
    }

    /* Sidebar */
    #sidebar {
      width:min(340px, 88vw);
      padding:16px; border-right:1px solid #2e2f3a; background:var(--panel);
      display:none; flex-direction:column; gap:12px;
      position:absolute; z-index:40; left:12px; top:60px;
      border-radius:12px; box-shadow:0 20px 60px var(--shadow);
    }
    #sidebar h1 { font-size:18px; }
    #sidebar .hint { font-size:14px; line-height:1.5; padding:10px; border-radius:10px; background:var(--muted); border:1px solid var(--muted-2); }

    /* Canvas area */
    #canvas-wrapper { flex:1; position:relative; overflow:hidden; }
    #canvas { width:100%; height:100%; background: radial-gradient(circle at top left, #25273a 0, #151623 55%); }
    #canvas, .node { touch-action:none; }

    .node { cursor: grab; transition: transform 120ms ease; transform-box: fill-box; transform-origin: center; }
    .node:active { cursor: grabbing; }
    .node:hover { transform: scale(1.06); }
    .node text { fill:var(--text); font-size:16px; pointer-events:none; }

    .link { stroke:var(--text); stroke-width:2; stroke-linecap:round; }
    .link-shadow { stroke:rgba(0,0,0,0.6); stroke-width:4; stroke-linecap:round; }
    #temp-link { stroke:#fbbf24; stroke-width:2; stroke-dasharray:4 3; stroke-linecap:round; pointer-events:none; display:none; }

    #status {
      position:absolute; left:12px; bottom:12px;
      padding:8px 12px; border-radius:999px;
      background:rgba(15,23,42,0.88); border:1px solid rgba(148,163,184,0.5);
      font-size:14px;
    }

    #menu {
      position:absolute; min-width:200px; background:#0f172a; border:1px solid #334155;
      border-radius:10px; box-shadow:0 10px 30px var(--shadow); padding:6px; display:none; z-index:20;
    }
    #menu button {
      width:100%; text-align:left; padding:10px 12px; background:transparent; color:var(--text);
      border:none; border-radius:8px; font-size:16px;
    }
    #menu button:hover { background:#1f2937; }
    #menu .danger:hover { background:#3b1f27; color:#fecaca; }
    #menu hr { border:0; border-top:1px solid #334155; margin:6px 0; }

    /* Topbar */
    #topbar {
      position: absolute; right: 12px; top: 12px; z-index: 35;
      display: flex; gap: 8px; background: var(--pill); border: 1px solid var(--pill-b);
      padding: 6px 8px; border-radius: 999px; font-size: 14px; align-items: center;
    }
    #topbar .label, #topbar .kbd, #topbar .sep { display:none; }

    .btn {
      appearance: none; border: 1px solid var(--muted-2); background: var(--muted);
      color: var(--text); padding: 8px 12px; border-radius: 10px; font-size: 16px; cursor: pointer;
    }
    .btn:hover { filter: brightness(1.06); }
    .btn.primary { background:#1f2a44; border-color:#2a3a5f; }
    .btn.danger  { background:#3b1f27; border-color:#5b2531; color:#fecaca; }

    #btn-help, #btn-switch, #btn-new { display:inline-flex; align-items:center; justify-content:center; min-width:44px; }
    #btn-dup, #btn-del, #btn-undo, #btn-redo, #btn-save { display:none; }

    @media (min-width: 768px) {
      #topbar .label, #topbar .kbd, #topbar .sep { display:inline; }
      #btn-dup, #btn-del, #btn-undo, #btn-redo, #btn-save { display:inline-flex; }
    }

    /* Palette */
    #palette {
      position:absolute; right:12px; bottom:12px; z-index:15; display:flex; gap:10px;
      background: var(--pill); border:1px solid var(--pill-b); padding:8px 10px; border-radius:12px; align-items:center;
    }
    .swatch { width:28px; height:28px; border-radius:6px; border:1px solid rgba(255,255,255,.2); cursor:pointer; position:relative; }
    .swatch.selected { outline:2px solid #fff; outline-offset:2px; }
    .swatch.picker { display:grid; place-items:center; font-size:18px; width:32px; height:32px; border-radius:8px; }
    .swatch.picker span { pointer-events:none; }

    /* Invisible color-input overlay anchored to ＋ swatch */
    #palette-color-input {
      position:fixed;
      width:32px; height:32px;
      opacity:0.0001;
      border:none; padding:0; margin:0;
      background:transparent;
      z-index:16;
    }

    .disabled-cover { position:absolute; inset:0; pointer-events:auto; }

    /* Project gate modal */
    #project-gate{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.6); z-index:50;
    }
    #project-card{
      width:min(620px,92vw); background:var(--panel); border:1px solid var(--muted-2);
      border-radius:14px; box-shadow:0 20px 60px var(--shadow); padding:16px; display:flex; flex-direction:column; gap:10px;
    }
    #project-card h2{ font-size:18px; margin-bottom:6px; }
    #projects-list{ max-height:260px; overflow:auto; border:1px solid var(--muted-2); border-radius:10px; padding:4px; background:var(--bg); }
    .proj-row{ display:flex; align-items:center; justify-content:space-between; padding:10px; border-radius:8px; gap:10px; }
    .proj-row:hover{ background:#222536; }
    .proj-name{ font-size:16px; }
    .proj-meta{ font-size:12px; opacity:.8; }
    .row-actions{ display:flex; gap:8px; }
    #project-form{ display:flex; gap:8px; margin-top:8px; }
    #project-name{
      flex:1; padding:10px 12px; border-radius:8px; border:1px solid var(--muted-2);
      background:#0f1222; color:#e5e7eb; font-size:16px;
    }

    /* --- Mobile UI additions (exact placement: appended at end of <style>) --- */
    #hamburger{position:absolute;right:12px;top:12px;z-index:40;background:var(--pill);border:1px solid var(--pill-b);border-radius:10px;width:44px;height:44px;display:grid;place-items:center}
    #hamburger span{font-size:20px;line-height:1}
    #hamburger-menu{position:absolute;right:12px;top:60px;z-index:41;background:#0f172a;border:1px solid #334155;border-radius:12px;box-shadow:0 12px 30px var(--shadow);display:none;min-width:200px;overflow:hidden}
    #hamburger-menu button{width:100%;padding:12px 14px;background:transparent;border:0;color:var(--text);text-align:left;font-size:16px}
    #hamburger-menu button:hover{background:#1f2937}

    #mobile-undo-redo{position:absolute;left:12px;top:12px;z-index:40;display:flex;gap:8px;background:var(--pill);border:1px solid var(--pill-b);padding:6px;border-radius:999px}
    @media(min-width:768px){#mobile-undo-redo,#hamburger,#hamburger-menu{display:none}}

    #tool-rail{position:absolute;left:12px;top:68px;bottom:12px;width:56px;z-index:38;display:flex;flex-direction:column;gap:10px}
    .tool{flex:0 0 auto;display:grid;place-items:center;height:44px;border-radius:10px;border:1px solid var(--muted-2);background:var(--muted);font-size:12px}
    .tool.active{outline:2px solid #fff;outline-offset:2px}
    .tool .lbl{pointer-events:none;font-size:11px}
  </style>
</head>
<body>
  <aside id="sidebar">
    <h1>Node Canvas</h1>
    <div class="hint">
      • Create/open a project to enable the canvas.<br>
      • Drag a node to move it (links follow). Long-press a node for actions.<br>
      • Desktop: hover a node and press N to start a link.<br>
      • Touch: start connection, touch canvas to begin guide, lift on target node.<br>
      • Undo/Redo: Ctrl/⌘+Z / Ctrl/⌘+Y (desktop). Save: Ctrl/⌘+S.
    </div>
  </aside>

  <div id="canvas-wrapper">
    <svg id="canvas">
      <g id="links-layer"></g>
      <line id="temp-link" x1="0" y1="0" x2="0" y2="0"></line>
      <g id="nodes-layer"></g>
    </svg>

    <div id="menu">
      <button data-action="connect">Start connection</button>
      <button data-action="rename">Rename…</button>
      <button data-action="duplicate">Duplicate</button>
      <hr>
      <button class="danger" data-action="delete">Delete</button>
    </div>

    <div id="topbar">
      <button id="btn-help" class="btn" title="Show help">?</button>
      <span class="label">Project:</span>
      <span id="proj-label" class="kbd">—</span>
      <span class="sep">|</span>
      <button id="btn-switch" class="btn">Open…</button>
      <button id="btn-new" class="btn">New…</button>
      <button id="btn-dup" class="btn">Duplicate…</button>
      <button id="btn-del" class="btn danger">Delete</button>
      <span class="sep">|</span>
      <button id="btn-undo" class="btn">Undo</button>
      <button id="btn-redo" class="btn">Redo</button>
      <span class="sep">|</span>
      <button id="btn-save" class="btn primary">Save</button>
    </div>

    <div id="palette"></div>
    <input id="palette-color-input" type="color" aria-label="Pick color" />

    <div id="status">Mode: create/open a project</div>

    <div id="project-gate" style="display:none;">
      <div id="project-card">
        <h2>Projects</h2>
        <div id="projects-list"></div>
        <div id="project-form">
          <input id="project-name" placeholder="New project name" />
          <button id="create-project" class="btn primary">Create</button>
        </div>
      </div>
    </div>

    <div id="gate-cover" class="disabled-cover" style="display:none;"></div>

    <!-- Mobile controls (exact placement: appended at end of #canvas-wrapper) -->
    <button id="hamburger" aria-label="Menu"><span>☰</span></button>
    <div id="hamburger-menu" role="menu">
      <button data-mobile="open">Open</button>
      <button data-mobile="new">New</button>
      <button data-mobile="dup">Duplicate</button>
      <button data-mobile="del">Delete</button>
      <button data-mobile="hint">Hint</button>
    </div>

    <div id="mobile-undo-redo">
      <button id="m-undo" class="btn" title="Undo">↶</button>
      <button id="m-redo" class="btn" title="Redo">↷</button>
    </div>

    <div id="tool-rail">
      <button id="tool-lines"  class="tool" title="Lines mode"><span class="lbl">Lines</span></button>
      <button id="tool-edit"   class="tool" title="Edit mode"><span class="lbl">Edit</span></button>
      <button id="tool-delete" class="tool" title="Delete mode"><span class="lbl">Delete</span></button>
    </div>
  </div>

  <script>
    (function(){
      // ----- Core refs -----
      const svg = document.getElementById("canvas");
      const nodesLayer = document.getElementById("nodes-layer");
      const linksLayer = document.getElementById("links-layer");
      const tempLink = document.getElementById("temp-link");
      const statusEl = document.getElementById("status");
      const menu = document.getElementById("menu");
      const wrapper = document.getElementById("canvas-wrapper");
      const sidebar = document.getElementById("sidebar");
      const btnHelp = document.getElementById("btn-help");

      const gate = document.getElementById("project-gate");
      const listEl = document.getElementById("projects-list");
      const projNameInput = document.getElementById("project-name");
      const createBtn = document.getElementById("create-project");
      const projLabel = document.getElementById("proj-label");

      const btnSwitch = document.getElementById("btn-switch");
      const btnNew    = document.getElementById("btn-new");
      const btnDup    = document.getElementById("btn-dup");
      const btnDel    = document.getElementById("btn-del");
      const btnUndo   = document.getElementById("btn-undo");
      const btnRedo   = document.getElementById("btn-redo");
      const btnSave   = document.getElementById("btn-save");
      const gateCover = document.getElementById("gate-cover");

      const paletteEl = document.getElementById("palette");
      const colorInput = document.getElementById("palette-color-input");

      /* Mobile refs (exact placement: appended within Core refs) */
      const hamburger = document.getElementById("hamburger");
      const hambMenu  = document.getElementById("hamburger-menu");
      const mUndo     = document.getElementById("m-undo");
      const mRedo     = document.getElementById("m-redo");
      const toolLines = document.getElementById("tool-lines");
      const toolEdit  = document.getElementById("tool-edit");
      const toolDelete= document.getElementById("tool-delete");

      // ----- Graph state -----
      let nodes = [], links = [], nextId = 1;

      // Palette state
      let palette = { colors: ['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected: 0 };

      let dragNode = null;
      let dragOffset = {x:0,y:0};
      let linkingFrom = null;
      let linkActive = false;       // follows pointer while linking
      let menuNode = null;
      let lastHoverNode = null;
      let dragCandidate = null;
      let selectedNodeId = null;

      // Pointer UX
      const LONG_PRESS_MS = 500;
      const DRAG_MENU_CANCEL_PX = 6;
      let pressTimer = null;
      let downX=0, downY=0;

      // Projects/History (IndexedDB)
      let db = null;
      const DB_NAME = "node-editor";
      const DB_VER = 1;
      let currentProject = null;
      let undoStack = [];
      let redoStack = [];

      /* Mobile tool modes (exact placement: appended near other state) */
      let linesMode = false;   // tap sequence of nodes to chain-connect
      let editMode  = false;   // tap opens node context menu
      let deleteMode= false;   // tap deletes node
      let chainFrom = null;    // last node tapped in linesMode
      let tapMoved  = false;   // tracks movement to distinguish drag vs tap

      // ----- Utils -----
      function setStatus(text){ statusEl.textContent = text; }
      function svgPoint(evt){
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX; pt.y = evt.clientY;
        return pt.matrixTransform(svg.getScreenCTM().inverse());
      }
      function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }
      const selectedColor = ()=> palette.colors[palette.selected] || '#3b82f6';
      const normHex = (v)=>{
        let s = String(v||'').trim();
        if (!s) return '#3b82f6';
        if (s[0] !== '#') s = '#'+s;
        if (/^#([0-9a-f]{3})$/i.test(s)) s = '#'+s.slice(1).split('').map(x=>x+x).join('');
        if (!/^#([0-9a-f]{6})$/i.test(s)) return '#3b82f6';
        return s.toLowerCase();
      };

      // ----- IndexedDB -----
      function openDB(){
        return new Promise((resolve, reject)=>{
          const req = indexedDB.open(DB_NAME, DB_VER);
          req.onupgradeneeded = (e)=>{
            const db = e.target.result;
            if (!db.objectStoreNames.contains("projects")) {
              const s = db.createObjectStore("projects", { keyPath: "id", autoIncrement: true });
              s.createIndex("by_name","name",{ unique: true });
            }
            if (!db.objectStoreNames.contains("states")) {
              const s2 = db.createObjectStore("states", { keyPath: ["projectId","rev"] });
              s2.createIndex("by_project","projectId");
            }
            if (!db.objectStoreNames.contains("history")) {
              const s3 = db.createObjectStore("history", { keyPath: ["projectId","seq"] });
              s3.createIndex("by_project","projectId");
            }
          };
          req.onsuccess = ()=> resolve(req.result);
          req.onerror   = ()=> reject(req.error);
        });
      }
      function tx(storeNames, mode="readonly"){ return db.transaction(storeNames, mode); }

      // ----- Projects API -----
      async function listProjects(){
        const out = [];
        await new Promise((res,rej)=>{
          const t = tx(["projects"]);
          const req = t.objectStore("projects").openCursor();
          req.onsuccess = (e)=>{ const cur=e.target.result; if(cur){ out.push(cur.value); cur.continue(); } else res(); };
          req.onerror  = ()=>rej(req.error);
        });
        return out.sort((a,b)=> (b.updatedAt||b.createdAt||0) - (a.updatedAt||a.createdAt||0));
      }
      async function createProject(name){
        const now = Date.now();
        const meta = { name, createdAt: now, updatedAt: now, pointer: 0, palette };
        const t = tx(["projects"],"readwrite");
        const req = t.objectStore("projects").add(meta);
        const id = await new Promise((res,rej)=>{ req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); });
        await saveStateSnapshot(id, 0, { nodes:[], links:[], nextId:1 });
        await saveHistoryRecord(id, 1, { type:"INIT", at: now });
        return { id, ...meta };
      }
      async function duplicateProject(sourceId, newName){
        const now = Date.now();
        const t = tx(["projects"],"readwrite");
        const origin = await new Promise((res,rej)=>{
          const r = t.objectStore("projects").get(sourceId);
          r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);
        });
        const addReq = t.objectStore("projects").add({ name:newName, createdAt: now, updatedAt: now, pointer: 0, palette: origin?.palette || palette });
        const newId = await new Promise((res,rej)=>{ addReq.onsuccess=()=>res(addReq.result); addReq.onerror=()=>rej(addReq.error); });

        let maxRev = 0;
        await new Promise((res,rej)=>{
          const t2 = tx(["states"],"readwrite");
          const idx = t2.objectStore("states").index("by_project").openCursor(IDBKeyRange.only(sourceId));
          idx.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {rev,state}=c.value; maxRev=Math.max(maxRev,rev); t2.objectStore("states").put({projectId:newId,rev,state:JSON.parse(JSON.stringify(state))}); c.continue(); } else res(); };
          idx.onerror=()=>rej(idx.error);
        });
        await new Promise((res,rej)=>{
          const t3 = tx(["history"],"readwrite");
          const idx = t3.objectStore("history").index("by_project").openCursor(IDBKeyRange.only(sourceId));
          idx.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {seq,action}=c.value; t3.objectStore("history").put({projectId:newId,seq,action:JSON.parse(JSON.stringify(action))}); c.continue(); } else res(); };
          idx.onerror=()=>rej(idx.error);
        });
        await new Promise((res,rej)=>{
          const t4 = tx(["projects"],"readwrite");
          const putReq = t4.objectStore("projects").put({ id:newId, name:newName, createdAt: now, updatedAt: now, pointer: maxRev, palette: origin?.palette || palette });
          putReq.onsuccess=()=>res(); putReq.onerror=()=>rej(putReq.error);
        });
        return { id:newId, name:newName, createdAt: now, updatedAt: now, pointer: maxRev, palette: origin?.palette || palette };
      }
      async function updateProjectMeta(patch){
        if (!currentProject) return;
        const now = Date.now();
        const t = tx(["projects"],"readwrite");
        const obj = { ...currentProject, ...patch, updatedAt: now };
        await new Promise((res,rej)=>{ const r=t.objectStore("projects").put(obj); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
        currentProject = obj;
        projLabel.textContent = currentProject.name;
      }

      // ----- Snapshots / History -----
      async function saveStateSnapshot(projectId, rev, state){
        const t = tx(["states"],"readwrite");
        await new Promise((res,rej)=>{ const r=t.objectStore("states").put({projectId,rev,state}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
      }
      async function loadLatestState(projectId){
        let maxRev=-1, latest=null;
        await new Promise((res,rej)=>{
          const t = tx(["states"]);
          const idx = t.objectStore("states").index("by_project");
          const r = idx.openCursor(IDBKeyRange.only(projectId));
          r.onsuccess=(e)=>{ const c=e.target.result; if(c){ const {rev,state}=c.value; if(rev>maxRev){maxRev=rev; latest={rev,state};} c.continue(); } else res(); };
          r.onerror=()=>rej(r.error);
        });
        return latest || { rev:0, state:{ nodes:[], links:[], nextId:1 } };
      }
      async function saveHistoryRecord(projectId, seq, action){
        const t = tx(["history"],"readwrite");
        await new Promise((res,rej)=>{ const r=t.objectStore("history").put({projectId,seq,action}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
      }
      async function loadHistory(projectId){
        const items=[];
        await new Promise((res,rej)=>{
          const t = tx(["history"]);
          const idx = t.objectStore("history").index("by_project");
          const r = idx.openCursor(IDBKeyRange.only(projectId));
          r.onsuccess=(e)=>{ const c=e.target.result; if(c){ items.push(c.value); c.continue(); } else res(); };
          r.onerror=()=>rej(r.error);
        });
        items.sort((a,b)=>a.seq-b.seq);
        return items;
      }

      // ----- History helpers -----
      function snapshot(){ return { nodes: JSON.parse(JSON.stringify(nodes)), links: JSON.parse(JSON.stringify(links)), nextId }; }
      function applyState(state){ nodes = JSON.parse(JSON.stringify(state.nodes||[])); links = JSON.parse(JSON.stringify(state.links||[])); nextId = state.nextId || 1; renderAll(); }
      async function pushAction(action){ if (!currentProject) return; undoStack.push(snapshot()); redoStack.length = 0; await appendHistory(action); updateProjectMeta({}); }
      async function appendHistory(action){ const all = await loadHistory(currentProject.id); const nextSeq = (all.length? all[all.length-1].seq+1 : 1); await saveHistoryRecord(currentProject.id, nextSeq, action); }
      async function rebuildStacksFromHistory(){ undoStack.length=0; redoStack.length=0; undoStack.push(snapshot()); }
      async function doUndo(){ if (!currentProject || undoStack.length<=1) return; const cur=undoStack.pop(); redoStack.push(cur); const prev=undoStack[undoStack.length-1]; applyState(prev); setStatus("Undo"); await persistSnapshot(); }
      async function doRedo(){ if (!currentProject || !redoStack.length) return; const nxt=redoStack.pop(); undoStack.push(nxt); applyState(nxt); setStatus("Redo"); await persistSnapshot(); }
      async function persistSnapshot(){ if (!currentProject) return; const latest=await loadLatestState(currentProject.id); const newRev=latest.rev+1; await saveStateSnapshot(currentProject.id,newRev,snapshot()); await updateProjectMeta({pointer:newRev, palette}); setStatus(`Saved rev ${newRev}`); }

      // ----- Graph CRUD -----
      function makeDefaultStyle(){ const c = selectedColor(); return { shape:'circle', fill:c, stroke:c }; }



      function addNodeWrapped(x,y){
        const node={id:nextId++,x,y,label:"N"+(nextId-1), style: makeDefaultStyle()};
        nodes.push(node);
        selectedNodeId = node.id;        // NEW: select the new node
        renderNodes();
        renderLinks();
        pushAction({type:"ADD_NODE",at:Date.now(),node});
      }




      function moveNodeWrapped(node){ renderLinks(); pushAction({type:"MOVE_NODE",at:Date.now(),id:node.id,x:node.x,y:node.y}); }

      function deleteNodeWrapped(node){
        nodes=nodes.filter(n=>n.id!==node.id);
        links=links.filter(l=>l.from!==node.id&&l.to!==node.id);
        if (selectedNodeId === node.id) selectedNodeId = null;  // NEW
        renderAll();
        pushAction({type:"DELETE_NODE",at:Date.now(),id:node.id});
      }




      function duplicateNodeWrapped(node, keepLabel=false){
        const newLabel = keepLabel ? (node.label ? node.label + "1" : "N"+nextId) : ("N"+nextId);
        const n2={ id:nextId++, x:node.x+28, y:node.y+28, label:newLabel, style: JSON.parse(JSON.stringify(node.style||makeDefaultStyle())) };
        nodes.push(n2); renderAll(); pushAction({type:"DUPLICATE_NODE",at:Date.now(),from:node.id,to:n2.id});
      }
      function connectNodesWrapped(aId,bId){ links.push({from:aId,to:bId, style:{color:selectedColor()}}); renderLinks(); pushAction({type:"CONNECT",at:Date.now(),from:aId,to:bId,color:selectedColor()}); }
      function renameNodeWrapped(node,newLabel){ const old=node.label; node.label=newLabel; updateNodeGraphics(node); pushAction({type:"RENAME_NODE",at:Date.now(),id:node.id,from:old,to:newLabel}); }
      function restyleNodeWrapped(node, patch){
        node.style = { ...(node.style||makeDefaultStyle()), ...patch };
        updateNodeGraphics(node);
        pushAction({type:"STYLE_NODE", at:Date.now(), id:node.id, patch});
      }

      // ----- Rendering -----
      function renderNodes() {
        nodesLayer.innerHTML = "";
        nodes.forEach(node => {
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.classList.add("node");
          g.dataset.id = String(node.id);

          const style = node.style || makeDefaultStyle();
          const isSelected = node.id === selectedNodeId;

          let shapeEl;
          if (style.shape === 'rect') {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            shapeEl.setAttribute("x", node.x - 18); shapeEl.setAttribute("y", node.y - 18);
            shapeEl.setAttribute("width", 36); shapeEl.setAttribute("height", 36); shapeEl.setAttribute("rx", 6);
          } else if (style.shape === 'triangle') {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            const p1 = `${node.x},${node.y-20}`, p2 = `${node.x-18},${node.y+16}`, p3 = `${node.x+18},${node.y+16}`;
            shapeEl.setAttribute("points", `${p1} ${p2} ${p3}`);
          } else {
            shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            shapeEl.setAttribute("cx", node.x); shapeEl.setAttribute("cy", node.y); shapeEl.setAttribute("r", 18);
          }

    // normal stroke vs selected stroke
          shapeEl.setAttribute("fill", style.fill);
          shapeEl.setAttribute("stroke", isSelected ? "#ffffff" : style.stroke);
          shapeEl.setAttribute("stroke-width", isSelected ? "3" : "2");

          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", node.x); text.setAttribute("y", node.y + 4); text.setAttribute("text-anchor", "middle");
          text.textContent = node.label;

          g.appendChild(shapeEl); g.appendChild(text); nodesLayer.appendChild(g);

          g.addEventListener("pointerenter", ()=>{ lastHoverNode = node; });
          g.addEventListener("pointerleave", ()=>{ if (lastHoverNode && lastHoverNode.id===node.id) lastHoverNode=null; });

          g.addEventListener("pointerdown", (e)=>onNodePointerDown(e, node));
          g.addEventListener("contextmenu", (e)=>openMenu(e, node));
          g.addEventListener("pointerdown", (e)=>startPressTimer(e, node));
          g.addEventListener("pointerup", cancelPressTimer, { passive:true });
          g.addEventListener("pointerleave", cancelPressTimer, { passive:true });

    /* Mobile taps and two-finger menu (unchanged) */
          g.addEventListener("pointerdown", ()=>{ tapMoved=false; });
          g.addEventListener("pointermove", ()=>{ tapMoved=true; });
          g.addEventListener("pointerup", (e)=> handleNodePointerUp(e, node), { passive:true });
          g.addEventListener("touchstart", (e)=> maybeTwoFingerMenu(e, node), { passive:false });
          g.addEventListener("touchend", clearTwoFingerTimer, { passive:true });
          g.addEventListener("touchmove", clearTwoFingerTimer, { passive:true });
        });
        setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
      }



      function renderLinks() {
        linksLayer.innerHTML = "";
        links.forEach(link => {
          const from = nodes.find(n => n.id === link.from);
          const to   = nodes.find(n => n.id === link.to);
          if (!from || !to) return;

          const shadow = document.createElementNS("http://www.w3.org/2000/svg", "line");
          shadow.classList.add("link-shadow");
          shadow.setAttribute("x1", from.x); shadow.setAttribute("y1", from.y);
          shadow.setAttribute("x2", to.x);   shadow.setAttribute("y2", to.y);

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.classList.add("link");
          line.setAttribute("x1", from.x); line.setAttribute("y1", from.y);
          line.setAttribute("x2", to.x);   line.setAttribute("y2", to.y);
          if (link.style && link.style.color) line.setAttribute("stroke", link.style.color);

          linksLayer.appendChild(shadow);
          linksLayer.appendChild(line);
        });
        setStatus(`Nodes: ${nodes.length} | Links: ${links.length}`);
      }
      function renderAll(){ renderNodes(); renderLinks(); }
      function updateNodeGraphics(){ renderAll(); }

      // ----- Context menu -----
// ----- Context menu -----
      function openMenu(e, node){
        if (linkingFrom || dragNode) return;
        e.preventDefault();

        cancelPressTimer();
        dragCandidate = null;

        closeMenu();
        menuNode = node;
        const rect = wrapper.getBoundingClientRect();
        const x = Math.min(e.clientX - rect.left, rect.width - 220);
        const y = Math.min(e.clientY - rect.top,  rect.height - 180);
        menu.style.left = x + "px";
        menu.style.top  = y + "px";
        menu.style.display = "block";
      }

      function closeMenu(){ menu.style.display = "none"; menuNode = null; }

      menu.addEventListener("click", (e)=>{
        const btn = e.target.closest("button");
        if (!btn || !menuNode) return;
        const action = btn.dataset.action;

        if (action === "connect") {
    // Hide the menu and start desktop-style linking (line follows pointer)
          const from = menuNode;
          closeMenu();
          startConnectionFrom(from, { immediateFollow: true });
          return;
        }

        if (action === "rename") {
          const val = prompt("New name:", menuNode.label);
          if (val && val.trim()) { renameNodeWrapped(menuNode, val.trim()); }
        }

        if (action === "duplicate") { duplicateNodeWrapped(menuNode, true); }
        if (action === "delete")    { deleteNodeWrapped(menuNode); }

        closeMenu();
      });

      wrapper.addEventListener("pointerdown", (e)=>{
        if (e.target === svg) closeMenu();
      });








      // ----- Keyboard (desktop) -----
      window.addEventListener("keydown", async (e)=>{
        const mod = e.ctrlKey || e.metaKey;
        const k = e.key.toLowerCase();

        if (mod && k==="s"){ e.preventDefault(); await persistSnapshot(); return; }
        if (mod && k==="z"){ e.preventDefault(); await doUndo(); return; }
        if (mod && k==="y"){ e.preventDefault(); await doRedo(); return; }
        if (k==="escape"){ closeMenu(); cancelLinking(); return; }

        if (!currentProject) return;
        if (k==="n"){
          if (!linkingFrom && lastHoverNode){
            closeMenu();
            // immediate cursor-follow for desktop quick-connect
            startConnectionFrom(lastHoverNode, { immediateFollow: true });
          }
        }
        if (k==="x"){ if (lastHoverNode){ deleteNodeWrapped(lastHoverNode); } }
        if (e.shiftKey && k==="d"){ if (lastHoverNode){ duplicateNodeWrapped(lastHoverNode, true); } }
      });




      // ----- Pointer-based drag/move -----
// ----- Pointer-based drag/move -----
// Handles press timing for long-press, guards against accidental drag showing the menu,
// enables right-click to open the contextual menu, and preserves linking completion.
      function startPressTimer(e, node){
        if (linkingFrom) return;
        cancelPressTimer();
        downX = e.clientX; downY = e.clientY;
  // Long-press opens contextual menu on touch/primary mouse when stationary.
        pressTimer = setTimeout(()=>{ openMenu(e, node); }, LONG_PRESS_MS);
      }

// Cancels any pending long-press timer when movement or release happens.
      function cancelPressTimer(){
        if (pressTimer){ clearTimeout(pressTimer); pressTimer=null; }
      }

// Pointer down on a node: primary starts drag, secondary opens menu, middle ignored.
// If linking is active and a node is pressed, completes the link.
      function onNodePointerDown(e, node){
        if (!currentProject){ gateOn(); return; }

  // Right-click → open menu immediately
        if (e.button === 2){
          openMenu(e, node);
          return;
        }
  // Ignore middle button
        if (e.button === 1) return;

  // If currently linking and a node is pressed, finish the connection.
        if (linkingFrom){
          e.preventDefault();
          if (node.id !== linkingFrom.id) { connectNodesWrapped(linkingFrom.id, node.id); }
          cancelLinking();
          return;
        }

        e.preventDefault();
        e.stopPropagation();

  // Do not start drag yet; just mark candidate
        dragCandidate = { node, pointerId: e.pointerId };

        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onCanvasPointerMove);
        svg.addEventListener("pointerup", onCanvasPointerUp, { once:true });
      }


// Pointer move on canvas: cancels long-press if moved, updates temp link if linking,
// otherwise updates node position during drag and re-renders.
      function onCanvasPointerMove(e){
        if (pressTimer && dist(e.clientX,e.clientY,downX,downY) > DRAG_MENU_CANCEL_PX) {
          cancelPressTimer();
        }

        if (linkingFrom && linkActive){
          const p = svgPoint(e);
          tempLink.setAttribute("x2", p.x);
          tempLink.setAttribute("y2", p.y);
          return;
        }

  // No active drag yet: turn candidate into real drag if moved enough
        if (!dragNode && dragCandidate && e.pointerId === dragCandidate.pointerId){
          const p = svgPoint(e);
          const node = dragCandidate.node;
          dragNode = node;
          dragOffset.x = node.x - p.x;
          dragOffset.y = node.y - p.y;
          dragCandidate = null;

          // NEW: mark this node as selected (last dragged node)
          selectedNodeId = node.id;
          updateNodeGraphics();

          setStatus(`Dragging ${node.label}`);
        }

        if (!dragNode) return;

        const p = svgPoint(e);
        dragNode.x = p.x + dragOffset.x;
        dragNode.y = p.y + dragOffset.y;
        renderAll();
      }


// Pointer up on canvas: finalizes a drag operation and removes move tracking.
      function onCanvasPointerUp(e){
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        cancelPressTimer();
        dragCandidate = null;

        if (dragNode){
          moveNodeWrapped(dragNode);
          dragNode = null;
        }
      }





      // ----- Add node on empty canvas (mobile friendly) -----
      svg.addEventListener("pointerdown", (e)=>{
        if (e.button === 2) e.preventDefault();
        const isNode = !!e.target.closest(".node");
        const isLayer = (e.target === svg) || (e.target === nodesLayer) || (e.target === linksLayer);
        if (!isLayer && !isNode) return;
        if (!currentProject){ gateOn(); return; }
        if (linkingFrom){ cancelLinking(); setStatus("Link cancelled"); return; }
        if (isNode) return;
        const p = svgPoint(e);
        addNodeWrapped(p.x, p.y);
      });

      // ----- Linking (desktop + touch) -----
      function startConnectionFrom(node, opts={}){
        if (!node) return;

        // NEW: highlight starting node while in connection mode
        selectedNodeId = node.id;
        updateNodeGraphics();

        linkingFrom = node;
        tempLink.setAttribute("x1", node.x);
        tempLink.setAttribute("y1", node.y);
        tempLink.setAttribute("x2", node.x);
        tempLink.setAttribute("y2", node.y);
        tempLink.style.display = "block";

        if (opts.immediateFollow){
          linkActive = true;
          svg.addEventListener("pointermove", onCanvasPointerMove);
          setStatus(`Connecting from ${node.label}: move cursor, click a node to finish`);
        } else {
          setStatus(`Connecting from ${node.label}: touch canvas to start, lift on target node`);
          svg.addEventListener("pointerdown", onLinkPointerDown, { once:true });
        }
      }


      function onLinkPointerDown(e){
        if (!linkingFrom) return;
        e.preventDefault();
        linkActive = true;
        const p = svgPoint(e);
        tempLink.setAttribute("x2", p.x);
        tempLink.setAttribute("y2", p.y);
        svg.setPointerCapture(e.pointerId);
        svg.addEventListener("pointermove", onCanvasPointerMove);
        svg.addEventListener("pointerup", onLinkPointerUp, { once:true });
      }

      function onLinkPointerUp(e){
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        linkActive = false;

        const hit = document.elementFromPoint(e.clientX, e.clientY);
        let group = hit && hit.closest ? hit.closest(".node") : null;
        if (group && linkingFrom){
          const toId = Number(group.dataset.id);
          if (toId && toId !== linkingFrom.id){ connectNodesWrapped(linkingFrom.id, toId); }
        }
        cancelLinking();
      }

      function cancelLinking(){
        linkingFrom = null;
        linkActive = false;
        tempLink.style.display = "none";
        svg.removeEventListener("pointermove", onCanvasPointerMove);
        svg.removeEventListener("pointerdown", onLinkPointerDown);
      }




// prevent context menu while dragging/linking
// Suppresses native context menu only during drag or active linking;
// otherwise allows right-click/two-finger to open the app menu.
      nodesLayer.addEventListener("contextmenu", (e)=>{
        if (dragNode || linkingFrom){ e.preventDefault(); e.stopPropagation(); }
      });

// Allow native bubbling so node <g> handlers can open the custom menu.
// Only suppress on SVG root when actively dragging/linking.
      svg.addEventListener("contextmenu", (e)=>{
        if (dragNode || linkingFrom){ e.preventDefault(); }
      });





      // ----- Palette (anchored color input) -----
      function renderPalette(){
        paletteEl.innerHTML = "";

        // swatches
        palette.colors.slice(0,4).forEach((c, i)=>{
          const sw = document.createElement("div");
          sw.className = "swatch" + (palette.selected===i ? " selected" : "");
          sw.style.background = c;
          sw.title = `Color ${i+1}`;
          sw.addEventListener("click", ()=>{
            palette.selected = i;
            paletteEl.querySelectorAll(".swatch").forEach((el, idx)=>{
              if (!el.classList) return;
              if (idx === i) el.classList.add("selected");
              else el.classList.remove("selected");
            });
            updateProjectMeta({ palette });
            if (lastHoverNode) restyleNodeWrapped(lastHoverNode, { fill: palette.colors[i], stroke: palette.colors[i] });
            positionColorInput();
          });
          paletteEl.appendChild(sw);
        });

        // ＋ picker button
        const pickerBtn = document.createElement("div");
        pickerBtn.className = "swatch picker";
        pickerBtn.title = "Pick a color";
        pickerBtn.innerHTML = "<span>＋</span>";
        paletteEl.appendChild(pickerBtn);

        positionColorInput();
      }

      function positionColorInput(){
        const plus = paletteEl.querySelector(".swatch.picker");
        if (!plus) return;
        const r = plus.getBoundingClientRect();
        Object.assign(colorInput.style, {
          left: (r.left) + "px",
          top:  (r.top)  + "px",
          width: r.width + "px",
          height:r.height+ "px",
          display: "block"
        });
      }

      colorInput.addEventListener("input", (e)=>{
        const val = normHex(e.target.value);
        const idx = palette.selected || 0;
        palette.colors[idx] = val;
        const sw = paletteEl.querySelectorAll(".swatch")[idx];
        if (sw) sw.style.background = val;
        if (lastHoverNode) restyleNodeWrapped(lastHoverNode, { fill: val, stroke: val });
        setStatus(`Preview color #${idx+1} → ${val}`);
      });
      colorInput.addEventListener("change", async (e)=>{
        const val = normHex(e.target.value);
        const idx = palette.selected || 0;
        palette.colors[idx] = val;
        await updateProjectMeta({ palette });
        renderPalette();
        setStatus(`Color saved #${idx+1} → ${val}`);
      });

      window.addEventListener("resize", positionColorInput);

      // ----- Sidebar toggle -----
      let sidebarOpen = false;
      btnHelp.addEventListener("click", ()=>{
        sidebarOpen = !sidebarOpen;
        sidebar.style.display = sidebarOpen ? "flex" : "none";
      });
      btnHelp.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && sidebarOpen){ sidebarOpen=false; sidebar.style.display="none"; } });

      /* ----- Mobile UI behavior (exact placement: appended before Gate & boot) ----- */

      // Mobile hamburger dropdown: mirrors existing actions
      hamburger.addEventListener("click", ()=>{
        hambMenu.style.display = (hambMenu.style.display==="block") ? "none" : "block";
      });
      document.addEventListener("pointerdown", (e)=>{
        if (!hambMenu.contains(e.target) && e.target !== hamburger){
          hambMenu.style.display = "none";
        }
      });
      hambMenu.addEventListener("click", async (e)=>{
        const b = e.target.closest("button"); if (!b) return;
        const act = b.getAttribute("data-mobile");
        if (act==="open"){ await refreshProjectList(); gateOn(); setStatus("Open project"); }
        if (act==="new"){
          const name = prompt("New project name:"); if (!name || !name.trim()) return;
          try{ const p = await createProject(name.trim()); await refreshProjectList(); await openProject(p); }
          catch(err){ setStatus("Create failed (name exists?)"); }
        }
        if (act==="dup"){
          if (!currentProject){ setStatus("No project to duplicate"); return; }
          await persistSnapshot();
          const name = prompt(`Duplicate "${currentProject.name}" as:`); if (!name || !name.trim()) return;
          try{ const dup = await duplicateProject(currentProject.id, name.trim()); await refreshProjectList(); await openProject(dup); setStatus(`Duplicated as "${dup.name}"`); }
          catch(err){ setStatus("Duplicate failed (name exists?)"); }
        }
        if (act==="del"){
          if (!currentProject) return;
          const ok = confirm(`Delete project "${currentProject.name}"? This cannot be undone.`); if (!ok) return;
          await deleteProject(currentProject.id); await refreshProjectList(); gateOn();
        }
        if (act==="hint"){
          sidebarOpen = true; sidebar.style.display = "flex";
        }
        hambMenu.style.display = "none";
      });

      // Mobile Undo/Redo buttons
      mUndo.addEventListener("click", doUndo);
      mRedo.addEventListener("click", doRedo);

      // Tool rail: Lines/Edit/Delete modes
      function syncToolButtons(){
        toolLines.classList.toggle("active",  linesMode);
        toolEdit.classList.toggle("active",   editMode);
        toolDelete.classList.toggle("active", deleteMode);
      }
      toolLines.addEventListener("click", ()=>{
        linesMode = !linesMode;
        if (!linesMode) chainFrom = null;
        if (linesMode){ editMode=false; deleteMode=false; }
        syncToolButtons();
        setStatus(linesMode ? "Lines mode: tap nodes to chain" : "Lines mode off");
      });
      toolEdit.addEventListener("click", ()=>{
        editMode = !editMode;
        if (editMode){ linesMode=false; chainFrom=null; deleteMode=false; }
        syncToolButtons();
        setStatus(editMode ? "Edit mode: tap a node for menu" : "Edit mode off");
      });
      toolDelete.addEventListener("click", ()=>{
        deleteMode = !deleteMode;
        if (deleteMode){ linesMode=false; chainFrom=null; editMode=false; }
        syncToolButtons();
        setStatus(deleteMode ? "Delete mode: tap a node to remove" : "Delete mode off");
      });
      syncToolButtons();




      // Node tap handler for Lines/Edit/Delete modes
      function handleNodePointerUp(e, node){
        if (tapMoved) return;
        if (!currentProject) return;
        if (deleteMode){
          deleteNodeWrapped(node);
          return;
        }
        
        if (linesMode){
          if (!chainFrom){
            chainFrom = node;
            selectedNodeId = node.id;   // NEW: highlight chain start
            updateNodeGraphics();
            setStatus(`Chain start: ${node.label}`);
            return;
          }
          if (chainFrom.id !== node.id){
            connectNodesWrapped(chainFrom.id, node.id);
            setStatus(`Linked ${chainFrom.label} → ${node.label}`);
          }
          chainFrom = node;
          selectedNodeId = node.id;     // NEW: move selection along the chain
          updateNodeGraphics();
          return;
        }

        if (editMode){
          const fake = { preventDefault: ()=>{}, clientX: e.clientX, clientY: e.clientY };
          openMenu(fake, node);
          return;
        }
      }




      // Two-finger long-press to open menu (touch)
      let twoFingerTimer = null;
      function maybeTwoFingerMenu(e, node){
        if (!editMode && e.touches && e.touches.length===2){
          e.preventDefault();
          clearTwoFingerTimer();
          const t = e.touches[0];
          twoFingerTimer = setTimeout(()=>{
            const fake = { preventDefault: ()=>{}, clientX: t.clientX, clientY: t.clientY };
            openMenu(fake, node);
          }, LONG_PRESS_MS);
        }
      }
      function clearTwoFingerTimer(){ if (twoFingerTimer){ clearTimeout(twoFingerTimer); twoFingerTimer=null; } }

      // ----- Gate & boot -----
      function gateOn(){ gate.style.display = "flex"; gateCover.style.display = "block"; }
      function gateOff(){ gate.style.display = "none"; gateCover.style.display = "none"; }

      async function refreshProjectList(){
        const items = await listProjects();
        listEl.innerHTML = "";
        if (items.length===0){
          const d = document.createElement("div");
          d.className="proj-row";
          d.innerHTML = `<span class="proj-meta">No projects yet.</span>`;
          listEl.appendChild(d);
          return;
        }
        items.forEach(p=>{
          const row = document.createElement("div");
          row.className="proj-row";
          row.innerHTML = `
            <div>
              <div class="proj-name">${p.name}</div>
              <div class="proj-meta">Updated: ${new Date(p.updatedAt||p.createdAt).toLocaleString()}</div>
            </div>
            <div class="row-actions">
              <button class="btn primary" data-open="${p.id}">Open</button>
              <button class="btn" data-dup="${p.id}">Duplicate…</button>
              <button class="btn danger" data-del="${p.id}">Delete</button>
          </div>`;
          listEl.appendChild(row);
        });
        listEl.querySelectorAll("[data-open]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-open"));
          const all = await listProjects();
          const match = all.find(x=>x.id===id);
          if (!match) return; await openProject(match);
        }));
        listEl.querySelectorAll("[data-dup]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-dup"));
          const name = prompt("Name for the duplicate:");
          if (!name || !name.trim()) return;
          try{ const dup = await duplicateProject(id, name.trim()); await refreshProjectList(); await openProject(dup); setStatus(`Duplicated as "${dup.name}"`); }
          catch(err){ setStatus("Duplicate failed (name exists?)"); }
        }));
        listEl.querySelectorAll("[data-del]").forEach(b=> b.addEventListener("click", async (e)=>{
          const id = Number(e.currentTarget.getAttribute("data-del"));
          await deleteProject(id); await refreshProjectList();
        }));
      }

      async function deleteProject(id){
        await new Promise((res,rej)=>{
          const t = tx(["projects","states","history"],"readwrite");
          t.objectStore("projects").delete(id);
          const s = t.objectStore("states").index("by_project").openCursor(IDBKeyRange.only(id));
          s.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("states").delete([id,c.value.rev]); c.continue(); } };
          const h = t.objectStore("history").index("by_project").openCursor(IDBKeyRange.only(id));
          h.onsuccess=(e)=>{ const c=e.target.result; if(c){ t.objectStore("history").delete([id,c.value.seq]); c.continue(); } };
          t.oncomplete=()=>res(); t.onerror=()=>rej(t.error);
        });
        if (currentProject && currentProject.id===id){ currentProject=null; gateOn(); clearGraph(); setStatus("Project deleted"); }
      }

      async function openProject(pMeta){
        currentProject = pMeta;
        projLabel.textContent = currentProject.name;
        palette = (pMeta.palette && Array.isArray(pMeta.palette.colors))
        ? { colors:[...pMeta.palette.colors], selected: Number(pMeta.palette.selected)||0 }
        : { colors:['#3b82f6','#22c55e','#f59e0b','#ef4444'], selected:0 };
        renderPalette();

        const latest = await loadLatestState(currentProject.id);
        applyState(latest.state);
        await rebuildStacksFromHistory();
        gateOff();
        setStatus(`Project opened: ${currentProject.name} | Nodes: ${nodes.length} | Links: ${links.length}`);
      }

      btnSwitch.addEventListener("click", async ()=>{ await refreshProjectList(); gateOn(); setStatus("Open project"); });
      btnNew.addEventListener("click", async ()=>{
        const name = prompt("New project name:"); if (!name || !name.trim()) return;
        try{ const p = await createProject(name.trim()); await refreshProjectList(); await openProject(p); }catch(e){ setStatus("Create failed (name exists?)"); }
      });
      btnDup.addEventListener("click", async ()=>{
        if (!currentProject) { setStatus("No project to duplicate"); return; }
        await persistSnapshot();
        const name = prompt(`Duplicate "${currentProject.name}" as:`); 
        if (!name || !name.trim()) return;
        try {
          const dup = await duplicateProject(currentProject.id, name.trim());
          await refreshProjectList();
          await openProject(dup);
          setStatus(`Duplicated as "${dup.name}"`);
        } catch(e) {
          setStatus("Duplicate failed (name exists?)");
        }
      });
      btnDel.addEventListener("click", async ()=>{
        if (!currentProject) return;
        const ok = confirm(`Delete project "${currentProject.name}"? This cannot be undone.`); if (!ok) return;
        await deleteProject(currentProject.id); await refreshProjectList(); gateOn();
      });
      createBtn.addEventListener("click", async ()=>{
        const name = (projNameInput.value||"").trim(); if (!name) return;
        try{ const p = await createProject(name); projNameInput.value = ""; await refreshProjectList(); await openProject(p); }
        catch(e){ setStatus("Project create error (name exists?)"); }
      });
      btnUndo.addEventListener("click", doUndo);
      btnRedo.addEventListener("click", doRedo);
      btnSave.addEventListener("click", persistSnapshot);

      function clearGraph(){ nodes=[]; links=[]; nextId=1; renderAll(); projLabel.textContent="—"; }

      async function boot(){
        svg.style.touchAction = "none";
        db = await openDB();
        await refreshProjectList();
        gateOn();
        clearGraph();
        renderPalette();
        requestAnimationFrame(positionColorInput);
        setStatus("Mode: create/open a project");
      }
      boot();
    })();
  </script>
</body>
</html>
